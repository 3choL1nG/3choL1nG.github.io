[{"title":"Mybaties-2","url":"/2021/09/30/mybatis-2/","content":"一.接口代理方式实现Dao1.1 代理开发方式介绍​    采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。\nMapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。\nMapper 接口开发需要遵循以下规范：\n1) Mapper.xml文件中的namespace与mapper接口的全限定名相同\n2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同\n3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同\n4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同\n总结: \n接口开发的方式: 程序员只需定义接口,就可以对数据库进行操作,那么具体的对象怎么创建?\n1.程序员负责定义接口\n2.在操作数据库,mybatis框架根据接口,通过动态代理的方式生成代理对象,负责数据库的crud操作\n1.2.编写StudentMapper接口\n1.3 测试代理方式public Student selectById(Integer id) &#123;       Student stu = null;       SqlSession sqlSession = null;       InputStream is = null;       try&#123;           //1.加载核心配置文件           is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);           //2.获取SqlSession工厂对象           SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);           //3.通过工厂对象获取SqlSession对象           sqlSession = sqlSessionFactory.openSession(true);           //4.获取StudentMapper接口的实现类对象           StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); // StudentMapper mapper = new StudentMapperImpl();           //5.通过实现类对象调用方法，接收结果           stu = mapper.selectById(id);       &#125; catch (Exception e) &#123;       &#125; finally &#123;           //6.释放资源           if(sqlSession != null) &#123;               sqlSession.close();           &#125;           if(is != null) &#123;               try &#123;                   is.close();               &#125; catch (IOException e) &#123;                   e.printStackTrace();               &#125;           &#125;       &#125;       //7.返回结果       return stu;   &#125;\n\n1.4 源码分析\n分析动态代理对象如何生成的？ \n通过动态代理开发模式，我们只编写一个接口，不写实现类，我们通过 getMapper() 方法最终获取到 org.apache.ibatis.binding.MapperProxy 代理对象，然后执行功能，而这个代理对象正是 MyBatis 使用了 JDK 的动态代理技术，帮助我们生成了代理实现类对象。从而可以进行相关持久化操作。 \n\n分析方法是如何执行的？\n 动态代理实现类对象在执行方法的时候最终调用了 mapperMethod.execute() 方法，这个方法中通过 switch 语句根据操作类型来判断是新增、修改、删除、查询操作，最后一步回到了 MyBatis 最原生的 SqlSession 方式来执行增删改查。    \n\n\n1.5 知识小结 接口代理方式可以让我们只编写接口即可，而实现类对象由 MyBatis 生成。 \n 实现规则 ：\n\n映射配置文件中的名称空间必须和 Dao 层接口的全类名相同。\n映射配置文件中的增删改查标签的 id 属性必须和 Dao 层接口的方法名相同。 \n映射配置文件中的增删改查标签的 parameterType 属性必须和 Dao 层接口方法的参数相同。 \n映射配置文件中的增删改查标签的 resultType 属性必须和 Dao 层接口方法的返回值相同。 \n获取动态代理对象 SqlSession 功能类中的 getMapper() 方法。    \n\n二. 动态sql语句2.1 动态sql语句概述​    Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。\n参考的官方文档，描述如下：\n\n2.2 动态 SQL  之&lt;if&gt;我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。\n如下图：\n&lt;select id=&quot;findByCondition&quot; parameterType=&quot;student&quot; resultType=&quot;student&quot;&gt;    select * from student    &lt;where&gt;        &lt;if test=&quot;id!=0&quot;&gt;            and id=#&#123;id&#125;        &lt;/if&gt;        &lt;if test=&quot;username!=null&quot;&gt;            and username=#&#123;username&#125;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;\n\n当查询条件id和username都存在时，控制台打印的sql语句如下：\n … … … //获得MyBatis框架生成的StudentMapper接口的实现类StudentMapper mapper = sqlSession.getMapper( StudentMapper.class);Student condition = new Student();condition.setId(1);condition.setUsername(&quot;lucy&quot;);Student student = mapper.findByCondition(condition);… … …\n\n\n当查询条件只有id存在时，控制台打印的sql语句如下：\n … … … //获得MyBatis框架生成的UserMapper接口的实现类 StudentMapper mapper = sqlSession.getMapper( StudentMapper.class);    Student condition = new Student();    condition.setId(1);    Student student = mapper.findByCondition(condition);… … …\n\n\n总结语法:\n&lt;where&gt;：条件标签。如果有动态条件，则使用该标签代替 where 关键字。&lt;if&gt;：条件判断标签。&lt;if test=“条件判断”&gt;\t查询条件拼接&lt;/if&gt;\n\n\n\n2.3  动态 SQL  之&lt;foreach&gt;循环执行sql的拼接操作，例如：SELECT * FROM student  WHERE id IN (1,2,5)。\n &lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;student&quot;&gt;    select * from student    &lt;where&gt;        &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;            #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n测试代码片段如下：\n … … … //获得MyBatis框架生成的UserMapper接口的实现类StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);int[] ids = new int[]&#123;2,5&#125;;List&lt;Student&gt; sList = mapper.findByIds(ids);System.out.println(sList);… … …\n\n总结语法:\n&lt;foreach&gt;：循环遍历标签。适用于多个参数或者的关系。    &lt;foreach collection=“”open=“”close=“”item=“”separator=“”&gt;\t\t获取参数\t&lt;/foreach&gt;\n\n属性collection：参数容器类型， (list-集合， array-数组)。open：开始的 SQL 语句。close：结束的 SQL 语句。item：参数变量名。separator：分隔符。\n2.4  SQL片段抽取Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的\n&lt;!--抽取sql片段简化编写--&gt;&lt;sql id=&quot;selectStudent&quot; select * from student&lt;/sql&gt;&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;student&quot;&gt;    &lt;include refid=&quot;selectStudent&quot;&gt;&lt;/include&gt; where id=#&#123;id&#125;&lt;/select&gt;&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;student&quot;&gt;    &lt;include refid=&quot;selectStudent&quot;&gt;&lt;/include&gt;    &lt;where&gt;        &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;            #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n总结语法:\n我们可以将一些重复性的 SQL 语句进行抽取，以达到复用的效果。 \n-  &lt;sql&gt;：抽取 SQL 语句标签。 -  &lt;include&gt;：引入 SQL 片段标签。    &lt;sql id=“片段唯一标识”&gt;抽取的 SQL 语句&lt;/sql&gt; &lt;include refid=“片段唯一标识”/&gt; \n\n2.5 知识小结MyBatis映射文件配置：\n&lt;select&gt;：查询&lt;insert&gt;：插入&lt;update&gt;：修改&lt;delete&gt;：删除&lt;where&gt;：where条件&lt;if&gt;：if判断&lt;foreach&gt;：循环&lt;sql&gt;：sql片段抽取\n\n\n\n三. 分页插件3.1 分页插件介绍\n\n分页可以将很多条结果进行分页显示。 \n 如果当前在第一页，则没有上一页。如果当前在最后一页，则没有下一页。 \n 需要明确当前是第几页，这一页中显示多少条结果。    \nMyBatis分页插件总结\n在企业级开发中，分页也是一种常见的技术。而目前使用的 MyBatis 是不带分页功能的，如果想实现分页的 功能，需要我们手动编写 LIMIT 语句。但是不同的数据库实现分页的 SQL 语句也是不同的，所以手写分页 成本较高。这个时候就可以借助分页插件来帮助我们实现分页功能。 \nPageHelper：第三方分页助手。将复杂的分页操作进行封装，从而让分页功能变得非常简单。    \n\n\n\n3.2 分页插件的使用MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据\n开发步骤：\n①导入与PageHelper的jar包\n②在mybatis核心配置文件中配置PageHelper插件\n&lt;!-- 注意：分页助手的插件  配置在通用mapper之前 --&gt;&lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;    &lt;!-- 指定方言 --&gt;    &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;&lt;/plugin&gt;\n\n③测试分页数据获取\n@Testpublic void testPageHelper()&#123;    //设置分页参数    PageHelper.startPage(1,2);    List&lt;User&gt; select = userMapper2.select(null);    for(User user : select)&#123;        System.out.println(user);    &#125;&#125;\n\n3.3 分页插件的参数获取获得分页相关的其他参数：\n//其他分页的数据PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(select);System.out.println(&quot;总条数：&quot;+pageInfo.getTotal());System.out.println(&quot;总页数：&quot;+pageInfo.getPages());System.out.println(&quot;当前页：&quot;+pageInfo.getPageNum());System.out.println(&quot;每页显示长度：&quot;+pageInfo.getPageSize());System.out.println(&quot;是否第一页：&quot;+pageInfo.isIsFirstPage());System.out.println(&quot;是否最后一页：&quot;+pageInfo.isIsLastPage());\n\n3.4  分页插件知识小结​    分页：可以将很多条结果进行分页显示。 \n\n分页插件 jar 包： pagehelper-5.1.10.jar jsqlparser-3.1.jar \n\n ：集成插件标签。 \n\n分页助手相关 API \n​    1.PageHelper：分页助手功能类。\n\nstartPage()：设置分页参数 \nPageInfo：分页相关参数功能类。 \ngetTotal()：获取总条数 \ngetPages()：获取总页数\n getPageNum()：获取当前页\n getPageSize()：获取每页显示条数\n getPrePage()：获取上一页 \ngetNextPage()：获取下一页 \nisIsFirstPage()：获取是否是第一页 \nisIsLastPage()：获取是否是最后一页    \n\n\n\n四.MyBatis的多表操作4.1 多表模型介绍我们之前学习的都是基于单表操作的，而实际开发中，随着业务难度的加深，肯定需要多表操作的。 \n\n 多表模型分类 一对一：在任意一方建立外键，关联对方的主键。\n 一对多：在多的一方建立外键，关联一的一方的主键。\n 多对多：借助中间表，中间表至少两个字段，分别关联两张表的主键。    \n\n4.2 多表模型一对一操作\n一对一模型： 人和身份证，一个人只有一个身份证\n\n代码实现\n\n步骤一: sql语句准备\nCREATE TABLE person(\tid INT PRIMARY KEY AUTO_INCREMENT,\tNAME VARCHAR(20),\tage INT);INSERT INTO person VALUES (NULL,&#x27;张三&#x27;,23);INSERT INTO person VALUES (NULL,&#x27;李四&#x27;,24);INSERT INTO person VALUES (NULL,&#x27;王五&#x27;,25);CREATE TABLE card(\tid INT PRIMARY KEY AUTO_INCREMENT,\tnumber VARCHAR(30),\tpid INT,\tCONSTRAINT cp_fk FOREIGN KEY (pid) REFERENCES person(id));INSERT INTO card VALUES (NULL,&#x27;12345&#x27;,1);INSERT INTO card VALUES (NULL,&#x27;23456&#x27;,2);INSERT INTO card VALUES (NULL,&#x27;34567&#x27;,3);\n步骤二:配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.table01.OneToOneMapper&quot;&gt;    &lt;!--配置字段和实体对象属性的映射关系--&gt;    &lt;resultMap id=&quot;oneToOne&quot; type=&quot;card&quot;&gt;        &lt;id column=&quot;cid&quot; property=&quot;id&quot; /&gt;        &lt;result column=&quot;number&quot; property=&quot;number&quot; /&gt;        &lt;!--            association：配置被包含对象的映射关系            property：被包含对象的变量名            javaType：被包含对象的数据类型        --&gt;        &lt;association property=&quot;p&quot; javaType=&quot;person&quot;&gt;            &lt;id column=&quot;pid&quot; property=&quot;id&quot; /&gt;            &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;            &lt;result column=&quot;age&quot; property=&quot;age&quot; /&gt;        &lt;/association&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectAll&quot; resultMap=&quot;oneToOne&quot;&gt;        SELECT c.id cid,number,pid,NAME,age FROM card c,person p WHERE c.pid=p.id    &lt;/select&gt;&lt;/mapper&gt;\n步骤三：测试类\n@Test   public void selectAll() throws Exception&#123;       //1.加载核心配置文件       InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);            //2.获取SqlSession工厂对象       SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);            //3.通过工厂对象获取SqlSession对象       SqlSession sqlSession = sqlSessionFactory.openSession(true);            //4.获取OneToOneMapper接口的实现类对象       OneToOneMapper mapper = sqlSession.getMapper(OneToOneMapper.class);            //5.调用实现类的方法，接收结果       List&lt;Card&gt; list = mapper.selectAll();            //6.处理结果       for (Card c : list) &#123;           System.out.println(c);       &#125;            //7.释放资源       sqlSession.close();       is.close();   &#125;\n\n3.一对一配置总结:\n&lt;resultMap&gt;：配置字段和对象属性的映射关系标签。    id 属性：唯一标识    type 属性：实体对象类型&lt;id&gt;：配置主键映射关系标签。&lt;result&gt;：配置非主键映射关系标签。    column 属性：表中字段名称    property 属性： 实体对象变量名称&lt;association&gt;：配置被包含对象的映射关系标签。    property 属性：被包含对象的变量名    javaType 属性：被包含对象的数据类型\n\n4.3 多表模型一对多操作\n一对多模型： 一对多模型：班级和学生，一个班级可以有多个学生。    \n\n代码实现\n\n步骤一: sql语句准备\nCREATE TABLE classes(\tid INT PRIMARY KEY AUTO_INCREMENT,\tNAME VARCHAR(20));INSERT INTO classes VALUES (NULL,&#x27;黑马一班&#x27;);INSERT INTO classes VALUES (NULL,&#x27;黑马二班&#x27;);CREATE TABLE student(\tid INT PRIMARY KEY AUTO_INCREMENT,\tNAME VARCHAR(30),\tage INT,\tcid INT,\tCONSTRAINT cs_fk FOREIGN KEY (cid) REFERENCES classes(id));INSERT INTO student VALUES (NULL,&#x27;张三&#x27;,23,1);INSERT INTO student VALUES (NULL,&#x27;李四&#x27;,24,1);INSERT INTO student VALUES (NULL,&#x27;王五&#x27;,25,2);INSERT INTO student VALUES (NULL,&#x27;赵六&#x27;,26,2);\n步骤二:配置文件\n&lt;mapper namespace=&quot;com.itheima.table02.OneToManyMapper&quot;&gt;    &lt;resultMap id=&quot;oneToMany&quot; type=&quot;classes&quot;&gt;        &lt;id column=&quot;cid&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;cname&quot; property=&quot;name&quot;/&gt;        &lt;!--            collection：配置被包含的集合对象映射关系            property：被包含对象的变量名            ofType：被包含对象的实际数据类型        --&gt;        &lt;collection property=&quot;students&quot; ofType=&quot;student&quot;&gt;            &lt;id column=&quot;sid&quot; property=&quot;id&quot;/&gt;            &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt;            &lt;result column=&quot;sage&quot; property=&quot;age&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectAll&quot; resultMap=&quot;oneToMany&quot;&gt;        SELECT c.id cid,c.name cname,s.id sid,s.name sname,s.age sage FROM classes c,student s WHERE c.id=s.cid    &lt;/select&gt;&lt;/mapper&gt;\n步骤三：测试类\n@Testpublic void selectAll() throws Exception&#123;    //1.加载核心配置文件    InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);         //2.获取SqlSession工厂对象    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);         //3.通过工厂对象获取SqlSession对象    SqlSession sqlSession = sqlSessionFactory.openSession(true);         //4.获取OneToManyMapper接口的实现类对象    OneToManyMapper mapper = sqlSession.getMapper(OneToManyMapper.class);         //5.调用实现类的方法，接收结果    List&lt;Classes&gt; classes = mapper.selectAll();         //6.处理结果    for (Classes cls : classes) &#123;        System.out.println(cls.getId() + &quot;,&quot; + cls.getName());        List&lt;Student&gt; students = cls.getStudents();        for (Student student : students) &#123;            System.out.println(&quot;\\t&quot; + student);        &#125;    &#125;         //7.释放资源    sqlSession.close();    is.close();&#125;\n\n3.一对多配置文件总结：\n&lt;resultMap&gt;：配置字段和对象属性的映射关系标签。    id 属性：唯一标识    type 属性：实体对象类型&lt;id&gt;：配置主键映射关系标签。&lt;result&gt;：配置非主键映射关系标签。    column 属性：表中字段名称    property 属性： 实体对象变量名称&lt;collection&gt;：配置被包含集合对象的映射关系标签。    property 属性：被包含集合对象的变量名    ofType 属性：集合中保存的对象数据类型\n\n\n\n4.4 多表模型多对多操作\n多对多模型：学生和课程，一个学生可以选择多门课程、一个课程也可以被多个学生所选择。       \n\n代码实现\n\n步骤一: sql语句准备\nCREATE TABLE course(\tid INT PRIMARY KEY AUTO_INCREMENT,\tNAME VARCHAR(20));INSERT INTO course VALUES (NULL,&#x27;语文&#x27;);INSERT INTO course VALUES (NULL,&#x27;数学&#x27;);CREATE TABLE stu_cr(\tid INT PRIMARY KEY AUTO_INCREMENT,\tsid INT,\tcid INT,\tCONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id),\tCONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id));INSERT INTO stu_cr VALUES (NULL,1,1);INSERT INTO stu_cr VALUES (NULL,1,2);INSERT INTO stu_cr VALUES (NULL,2,1);INSERT INTO stu_cr VALUES (NULL,2,2);\n步骤二:配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.table03.ManyToManyMapper&quot;&gt;    &lt;resultMap id=&quot;manyToMany&quot; type=&quot;student&quot;&gt;        &lt;id column=&quot;sid&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt;        &lt;result column=&quot;sage&quot; property=&quot;age&quot;/&gt;        &lt;collection property=&quot;courses&quot; ofType=&quot;course&quot;&gt;            &lt;id column=&quot;cid&quot; property=&quot;id&quot;/&gt;            &lt;result column=&quot;cname&quot; property=&quot;name&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectAll&quot; resultMap=&quot;manyToMany&quot;&gt;        SELECT sc.sid,s.name sname,s.age sage,sc.cid,c.name cname FROM student s,course c,stu_cr sc WHERE sc.sid=s.id AND sc.cid=c.id    &lt;/select&gt;&lt;/mapper&gt;\n步骤三：测试类\n@Test   public void selectAll() throws Exception&#123;       //1.加载核心配置文件       InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);            //2.获取SqlSession工厂对象       SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);            //3.通过工厂对象获取SqlSession对象       SqlSession sqlSession = sqlSessionFactory.openSession(true);            //4.获取ManyToManyMapper接口的实现类对象       ManyToManyMapper mapper = sqlSession.getMapper(ManyToManyMapper.class);            //5.调用实现类的方法，接收结果       List&lt;Student&gt; students = mapper.selectAll();            //6.处理结果       for (Student student : students) &#123;           System.out.println(student.getId() + &quot;,&quot; + student.getName() + &quot;,&quot; + student.getAge());           List&lt;Course&gt; courses = student.getCourses();           for (Course cours : courses) &#123;               System.out.println(&quot;\\t&quot; + cours);           &#125;       &#125;            //7.释放资源       sqlSession.close();       is.close();   &#125;   \n\n3.多对多配置文件总结：\n&lt;resultMap&gt;：配置字段和对象属性的映射关系标签。\tid 属性：唯一标识\ttype 属性：实体对象类型 &lt;id&gt;：配置主键映射关系标签。 &lt;result&gt;：配置非主键映射关系标签。\tcolumn 属性：表中字段名称\tproperty 属性： 实体对象变量名称&lt;collection&gt;：配置被包含集合对象的映射关系标签。\tproperty 属性：被包含集合对象的变量名\tofType 属性：集合中保存的对象数据类型\n\n\n\n4.5 多表模型操作总结 &lt;resultMap&gt;：配置字段和对象属性的映射关系标签。    id 属性：唯一标识    type 属性：实体对象类型&lt;id&gt;：配置主键映射关系标签。&lt;result&gt;：配置非主键映射关系标签。\tcolumn 属性：表中字段名称\tproperty 属性： 实体对象变量名称&lt;association&gt;：配置被包含对象的映射关系标签。\tproperty 属性：被包含对象的变量名\tjavaType 属性：被包含对象的数据类型&lt;collection&gt;：配置被包含集合对象的映射关系标签。\tproperty 属性：被包含集合对象的变量名\tofType 属性：集合中保存的对象数据类型\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["Java基础"],"tags":["Mybaties","Java"]},{"title":"Mybaties-1","url":"/2021/09/30/Mybaties-1/","content":"一.Mybatis快速入门1.1 框架介绍\n框架是一款半成品软件，我们可以基于这个半成品软件继续开发，来完成我们个性化的需求！\n\n如图:\n\n\n\n1.2 ORM介绍\nORM(Object Relational Mapping)： 对象关系映射\n\n指的是持久化数据和实体对象的映射模式，为了解决面向对象与关系型数据库存在的互不匹配的现象的技术。\n\n如图:\n\n\n具体映射关系如下图:\n\n\n\n1.3 原始jdbc操作（查询数据）\n1.4原始jdbc操作（插入数据）\n1.5 原始jdbc操作的分析\n原始 JDBC 的操作问题分析 \n​    1.频繁创建和销毁数据库的连接会造成系统资源浪费从而影响系统性能。\n\nsql 语句在代码中硬编码，如果要修改 sql 语句，就需要修改 java 代码，造成代码不易维护。\n查询操作时，需要手动将结果集中的数据封装到实体对象中。\n增删改查操作需要参数时，需要手动将实体对象的数据设置到 sql 语句的占位符。 \n\n\n原始 JDBC 的操作问题解决方案 \n​    1.使用数据库连接池初始化连接资源。 \n\n将 sql 语句抽取到配置文件中。 \n使用反射、内省等底层技术，将实体与表进行属性与字段的自动映射    \n\n\n\n1.6 什么是Mybatismybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。\nmybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。\n最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。\nMyBatis官网地址：http://www.mybatis.org/mybatis-3/ \n1.7  Mybatis的快速入门MyBatis开发步骤：\n①添加MyBatis的jar包\n②创建Student数据表\n③编写Studentr实体类 \n④编写映射文件StudentMapper.xml\n⑤编写核心文件MyBatisConfig.xml\n⑥编写测试类\n1.7.1  环境搭建1)导入MyBatis的jar包\n\nmysql-connector-java-5.1.37-bin.jar\nmybatis-3.5.3.jar\nlog4j-1.2.17.jar\n\n\n 创建student数据表\n\n\n\n编写Student实体\n\npublic class Student &#123;    private Integer id;    private String name;    private Integer age;    //省略get个set方法&#125;\n\n4)编写StudentMapper.xml映射文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!--MyBatis的DTD约束--&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--    mapper：核心根标签    namespace属性：名称空间--&gt;&lt;mapper namespace=&quot;StudentMapper&quot;&gt;    &lt;!--        select：查询功能的标签        id属性：唯一标识        resultType属性：指定结果映射对象类型        parameterType属性：指定参数映射对象类型    --&gt;    &lt;select id=&quot;selectAll&quot; resultType=&quot;student&quot;&gt;        SELECT * FROM student    &lt;/select&gt;&lt;/mapper&gt;\n\n\n编写MyBatis核心文件\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!--MyBatis的DTD约束--&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration 核心根标签--&gt;&lt;configuration&gt;    &lt;!--引入数据库连接的配置文件--&gt;    &lt;properties resource=&quot;jdbc.properties&quot;/&gt;    &lt;!--配置LOG4J--&gt;    &lt;settings&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;log4j&quot;/&gt;    &lt;/settings&gt;    &lt;!--起别名--&gt;    &lt;typeAliases&gt;        &lt;typeAlias type=&quot;com.itheima.bean.Student&quot; alias=&quot;student&quot;/&gt;        &lt;!--&lt;package name=&quot;com.itheima.bean&quot;/&gt;--&gt;    &lt;/typeAliases&gt;    &lt;!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;!--environment配置数据库环境  id属性唯一标识--&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;!-- dataSource数据源信息   type属性 连接池--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!-- property获取数据库连接的配置信息 --&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot; /&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot; /&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot; /&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot; /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!-- mappers引入映射配置文件 --&gt;    &lt;mappers&gt;        &lt;!-- mapper 引入指定的映射配置文件   resource属性指定映射配置文件的名称 --&gt;        &lt;mapper resource=&quot;StudentMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n1.7.2编写测试代码/*    控制层测试类 */public class StudentController &#123;    //创建业务层对象    private StudentService service = new StudentServiceImpl();    //查询全部功能测试    @Test    public void selectAll() &#123;        List&lt;Student&gt; students = service.selectAll();        for (Student stu : students) &#123;            System.out.println(stu);        &#125;    &#125;&#125;\n\n1.8 知识小结\n框架       \n 框架是一款半成品软件，我们可以基于框架继续开发，从而完成一些个性化的需求。\n\nORM        \n对象关系映射，数据和实体对象的映射。\n\nMyBatis       \n 是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC。\n\n\n二. MyBatis的相关api2.1 Resources\norg.apache.ibatis.io.Resources：加载资源的工具类。\n\n核心方法\n\n\n\n2.2 构建器SqlSessionFactoryBuilder\norg.apache.ibatis.session.SqlSessionFactoryBuilder：获取 SqlSessionFactory 工厂对象的功能类\n\n核心方法\n\n\n通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象\n\n\nString resource = &quot;org/mybatis/builder/mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream);\n\n其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。\n2.3 工厂对象SqlSessionFactory\norg.apache.ibatis.session.SqlSessionFactory：获取 SqlSession 构建者对象的工厂接口。\n\n核心api\n\n\n\n2.4 SqlSession会话对象\norg.apache.ibatis.session.SqlSession：构建者对象接口。用于执行 SQL、管理事务、接口代理。\n\n核心api\n\n\n\nSqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。\n三.MyBatis 映射配置文件3.1 映射配置文件介绍\n映射配置文件包含了数据和对象之间的映射关系以及要执行的 SQL 语句\n\n\n\n3.2 查询功能\n属性        \n id：唯一标识， 配合名称空间使用。     \n parameterType：指定参数映射的对象类型。       \n resultType：指定结果映射的对象类型。\n\nSQL 获取参数:        #{属性名}\n\n示例\n\n\n\n####3.3 新增功能 \n\n：新增功能标签。\n\n属性        \nid：唯一标识， 配合名称空间使用。     \nparameterType：指定参数映射的对象类型。       \nresultType：指定结果映射的对象类型。\n\nSQL 获取参数:        #{属性名}\n\n\n\n示例\n\n\n3.4 修改功能\n属性        \nid：唯一标识， 配合名称空间使用。     \nparameterType：指定参数映射的对象类型。       \nresultType：指定结果映射的对象类型。\n\nSQL 获取参数:        #{属性名}\n\n\n\n示例\n\n\n3.5 删除功能\n：查询功能标签。\n\n属性        \nid：唯一标识， 配合名称空间使用。     \nparameterType：指定参数映射的对象类型。       \nresultType：指定结果映射的对象类型。\n\nSQL 获取参数:        #{属性名}\n\n\n\n示例\n\n\n总结： 大家可以发现crud操作，除了标签名称以及sql语句不一样之外，其他属性参数基本一致。\n\n\n3.6 映射配置文件小结\n四.Mybatis核心配置文件介绍4.1 核心配置文件介绍核心配置文件包含了 MyBatis 最核心的设置和属性信息。如数据库的连接、事务、连接池信息等。\n如下图:\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!--MyBatis的DTD约束--&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration 核心根标签--&gt;&lt;configuration&gt;    &lt;!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;!--environment配置数据库环境  id属性唯一标识--&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;!-- dataSource数据源信息   type属性 连接池--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!-- property获取数据库连接的配置信息 --&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///db1&quot; /&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!-- mappers引入映射配置文件 --&gt;    &lt;mappers&gt;        &lt;!-- mapper 引入指定的映射配置文件   resource属性指定映射配置文件的名称 --&gt;        &lt;mapper resource=&quot;StudentMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n4.2 数据库连接配置文件引入\nproperties标签引入外部文件\n&lt;!--引入数据库连接的配置文件--&gt;&lt;properties resource=&quot;jdbc.properties&quot;/&gt;\n具体使用，如下配置\n&lt;!-- property获取数据库连接的配置信息 --&gt;  &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot; /&gt;  &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot; /&gt;  &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot; /&gt;  &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot; /&gt;\n\n4.3 起别名\n：为全类名起别名的父标签。\n\n：为全类名起别名的子标签。\n\n属性      \n type：指定全类名      \n alias：指定别名\n\n：为指定包下所有类起别名的子标签。(别名就是类名)\n\n如下图：\n\n\n具体如下配置\n&lt;!--起别名--&gt;&lt;typeAliases&gt;    &lt;typeAlias type=&quot;com.itheima.bean.Student&quot; alias=&quot;student&quot;/&gt;    &lt;!--&lt;package name=&quot;com.itheima.bean&quot;/&gt;--&gt;&lt;/typeAliase\n\n4.4 总结\n五.Mybatis传统方式开发5.1 Dao 层传统实现方式\n分层思想：控制层(controller)、业务层(service)、持久层(dao)。\n\n调用流程\n\n\n\n5.2 LOG4J的配置和使用\n在日常开发过程中，排查问题时难免需要输出 MyBatis 真正执行的 SQL 语句、参数、结果等信息，我们就可以借助 LOG4J 的功能来实现执行信息的输出。\n\n使用步骤：\n\n\n\n","categories":["Java基础"],"tags":["Mybaties","Java"]},{"title":"Mybaties-3","url":"/2021/09/30/mybatis-3/","content":"一.Mybatis注解开发单表操作1.1 MyBatis的常用注解这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper\n映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。\n@Insert：实现新增\n@Update：实现更新\n@Delete：实现删除\n@Select：实现查询\n@Result：实现结果集封装\n@Results：可以与@Result 一起使用，封装多个结果集\n@One：实现一对一结果集封装\n@Many：实现一对多结果集封装\n1.2 MyBatis的增删改查我们完成简单的student表的增删改查的操作\n\n步骤一:创建mapper接口\npublic interface StudentMapper &#123;    //查询全部    @Select(&quot;SELECT * FROM student&quot;)    public abstract List&lt;Student&gt; selectAll();    //新增操作    @Insert(&quot;INSERT INTO student VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)&quot;)    public abstract Integer insert(Student stu);    //修改操作    @Update(&quot;UPDATE student SET name=#&#123;name&#125;,age=#&#123;age&#125; WHERE id=#&#123;id&#125;&quot;)    public abstract Integer update(Student stu);    //删除操作    @Delete(&quot;DELETE FROM student WHERE id=#&#123;id&#125;&quot;)    public abstract Integer delete(Integer id);&#125;\n步骤二：测试类\npublic class Test01 &#123;    @Test    public void selectAll() throws Exception&#123;        //1.加载核心配置文件        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);        //2.获取SqlSession工厂对象        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);        //3.通过工厂对象获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession(true);        //4.获取StudentMapper接口的实现类对象        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);        //5.调用实现类对象中的方法，接收结果        List&lt;Student&gt; list = mapper.selectAll();        //6.处理结果        for (Student student : list) &#123;            System.out.println(student);        &#125;        //7.释放资源        sqlSession.close();        is.close();    &#125;    @Test    public void insert() throws Exception&#123;        //1.加载核心配置文件        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);        //2.获取SqlSession工厂对象        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);        //3.通过工厂对象获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession(true);        //4.获取StudentMapper接口的实现类对象        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);        //5.调用实现类对象中的方法，接收结果        Student stu = new Student(4,&quot;赵六&quot;,26);        Integer result = mapper.insert(stu);        //6.处理结果        System.out.println(result);        //7.释放资源        sqlSession.close();        is.close();    &#125;    @Test    public void update() throws Exception&#123;        //1.加载核心配置文件        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);        //2.获取SqlSession工厂对象        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);        //3.通过工厂对象获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession(true);        //4.获取StudentMapper接口的实现类对象        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);        //5.调用实现类对象中的方法，接收结果        Student stu = new Student(4,&quot;赵六&quot;,36);        Integer result = mapper.update(stu);        //6.处理结果        System.out.println(result);        //7.释放资源        sqlSession.close();        is.close();    &#125;    @Test    public void delete() throws Exception&#123;        //1.加载核心配置文件        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);        //2.获取SqlSession工厂对象        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);        //3.通过工厂对象获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession(true);        //4.获取StudentMapper接口的实现类对象        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);        //5.调用实现类对象中的方法，接收结果        Integer result = mapper.delete(4);        //6.处理结果        System.out.println(result);        //7.释放资源        sqlSession.close();        is.close();    &#125;&#125;\n注意：\n修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可\n\n\n&lt;mappers&gt;    &lt;!--扫描使用注解的类--&gt;    &lt;mapper class=&quot;com.itheima.mapper.UserMapper&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt;\n\n​    或者指定扫描包含映射关系的接口所在的包也可以\n&lt;mappers&gt;    &lt;!--扫描使用注解的类所在的包--&gt;    &lt;package name=&quot;com.itheima.mapper&quot;&gt;&lt;/package&gt;&lt;/mappers&gt;\n\n1.3 注解开发总结注解可以简化开发操作，省略映射配置文件的编写。 \n\n常用注解 \n@Select(“查询的 SQL 语句”)：执行查询操作注解\n @Insert(“查询的 SQL 语句”)：执行新增操作注解\n @Update(“查询的 SQL 语句”)：执行修改操作注解\n @Delete(“查询的 SQL 语句”)：执行删除操作注解 \n\n配置映射关系 \n&lt;mappers&gt; &lt;package name=&quot;接口所在包&quot;/&gt; &lt;/mappers&gt;    \n\n二.MyBatis注解开发的多表操作2.1  MyBatis的注解实现复杂映射开发实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置\n\n\n2.2  一对一查询2.2.1 一对一查询的模型一对一查询的需求：查询一个用户信息，与此同时查询出该用户对应的身份证信息\n\n2.2.2 一对一查询的语句对应的sql语句：\nSELECT * FROM card；SELECT * FROM person WHERE id=#&#123;id&#125;;\n\n2.2.3 创建PersonMapper接口public interface PersonMapper &#123;    //根据id查询    @Select(&quot;SELECT * FROM person WHERE id=#&#123;id&#125;&quot;)    public abstract Person selectById(Integer id);&#125;\n\n2.2.4 使用注解配置Mapperpublic interface CardMapper &#123;    //查询全部    @Select(&quot;SELECT * FROM card&quot;)    @Results(&#123;            @Result(column = &quot;id&quot;,property = &quot;id&quot;),            @Result(column = &quot;number&quot;,property = &quot;number&quot;),            @Result(                    property = &quot;p&quot;,             // 被包含对象的变量名                    javaType = Person.class,    // 被包含对象的实际数据类型                    column = &quot;pid&quot;,             // 根据查询出的card表中的pid字段来查询person表                    /*                        one、@One 一对一固定写法                        select属性：指定调用哪个接口中的哪个方法                     */                    one = @One(select = &quot;com.itheima.one_to_one.PersonMapper.selectById&quot;)            )    &#125;)    public abstract List&lt;Card&gt; selectAll();&#125;\n\n2.2.5 测试类public class Test01 &#123;    @Test    public void selectAll() throws Exception&#123;        //1.加载核心配置文件        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);        //2.获取SqlSession工厂对象        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);        //3.通过工厂对象获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession(true);        //4.获取CardMapper接口的实现类对象        CardMapper mapper = sqlSession.getMapper(CardMapper.class);        //5.调用实现类对象中的方法，接收结果        List&lt;Card&gt; list = mapper.selectAll();        //6.处理结果        for (Card card : list) &#123;            System.out.println(card);        &#125;        //7.释放资源        sqlSession.close();        is.close();    &#125;&#125;\n\n2.2.6  一对一配置总结@Results：封装映射关系的父注解。\tResult[] value()：定义了 Result 数组@Result：封装映射关系的子注解。\tcolumn 属性：查询出的表中字段名称\tproperty 属性：实体对象中的属性名称\tjavaType 属性：被包含对象的数据类型\tone 属性：一对一查询固定属性 @One：一对一查询的注解。\tselect 属性：指定调用某个接口中的方法\n\n\n\n2.3 一对多查询2.3.1 一对多查询的模型一对多查询的需求：查询一个课程，与此同时查询出该该课程对应的学生信息\n\n2.3.2 一对多查询的语句对应的sql语句：\nSELECT * FROM classesSELECT * FROM student WHERE cid=#&#123;cid&#125;\n\n2.3.3 创建StudentMapper接口public interface StudentMapper &#123;    //根据cid查询student表    @Select(&quot;SELECT * FROM student WHERE cid=#&#123;cid&#125;&quot;)    public abstract List&lt;Student&gt; selectByCid(Integer cid);&#125;\n\n2.3.4 使用注解配置Mapperpublic interface ClassesMapper &#123;    //查询全部    @Select(&quot;SELECT * FROM classes&quot;)    @Results(&#123;            @Result(column = &quot;id&quot;,property = &quot;id&quot;),            @Result(column = &quot;name&quot;,property = &quot;name&quot;),            @Result(                    property = &quot;students&quot;,  // 被包含对象的变量名                    javaType = List.class,  // 被包含对象的实际数据类型                    column = &quot;id&quot;,          // 根据查询出的classes表的id字段来查询student表                    /*                        many、@Many 一对多查询的固定写法                        select属性：指定调用哪个接口中的哪个查询方法                     */                    many = @Many(select = &quot;com.itheima.one_to_many.StudentMapper.selectByCid&quot;)            )    &#125;)    public abstract List&lt;Classes&gt; selectAll();&#125;\n\n2.3.5 测试类public class Test01 &#123;    @Test    public void selectAll() throws Exception&#123;        //1.加载核心配置文件        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);        //2.获取SqlSession工厂对象        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);        //3.通过工厂对象获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession(true);        //4.获取ClassesMapper接口的实现类对象        ClassesMapper mapper = sqlSession.getMapper(ClassesMapper.class);        //5.调用实现类对象中的方法，接收结果        List&lt;Classes&gt; list = mapper.selectAll();        //6.处理结果        for (Classes cls : list) &#123;            System.out.println(cls.getId() + &quot;,&quot; + cls.getName());            List&lt;Student&gt; students = cls.getStudents();            for (Student student : students) &#123;                System.out.println(&quot;\\t&quot; + student);            &#125;        &#125;        //7.释放资源        sqlSession.close();        is.close();    &#125;&#125;\n\n2.3.6 一对多配置总结@Results：封装映射关系的父注解。\tResult[] value()：定义了 Result 数组@Result：封装映射关系的子注解。\tcolumn 属性：查询出的表中字段名称\tproperty 属性：实体对象中的属性名称\tjavaType 属性：被包含对象的数据类型\tmany 属性：一对多查询固定属性@Many：一对多查询的注解。\tselect 属性：指定调用某个接口中的方法\n\n\n\n2.4  多对多查询2.4.1 多对多查询的模型多对多查询的需求：查询学生以及所对应的课程信息\n\n2.4.2 多对多查询的语句对应的sql语句：\nSELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.idSELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#&#123;id&#125;\n\n\n\n2.4.3  添加CourseMapper 接口方法public interface CourseMapper &#123;    //根据学生id查询所选课程    @Select(&quot;SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#&#123;id&#125;&quot;)    public abstract List&lt;Course&gt; selectBySid(Integer id);&#125;\n\n2.4.4 使用注解配置Mapperpublic interface StudentMapper &#123;    //查询全部    @Select(&quot;SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id&quot;)    @Results(&#123;            @Result(column = &quot;id&quot;,property = &quot;id&quot;),            @Result(column = &quot;name&quot;,property = &quot;name&quot;),            @Result(column = &quot;age&quot;,property = &quot;age&quot;),            @Result(                    property = &quot;courses&quot;,   // 被包含对象的变量名                    javaType = List.class,  // 被包含对象的实际数据类型                    column = &quot;id&quot;,          // 根据查询出student表的id来作为关联条件，去查询中间表和课程表                    /*                        many、@Many 一对多查询的固定写法                        select属性：指定调用哪个接口中的哪个查询方法                     */                    many = @Many(select = &quot;com.itheima.many_to_many.CourseMapper.selectBySid&quot;)            )    &#125;)    public abstract List&lt;Student&gt; selectAll();&#125;\n\n2.4.5 测试类public class Test01 &#123;    @Test    public void selectAll() throws Exception&#123;        //1.加载核心配置文件        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);        //2.获取SqlSession工厂对象        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);        //3.通过工厂对象获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession(true);        //4.获取StudentMapper接口的实现类对象        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);        //5.调用实现类对象中的方法，接收结果        List&lt;Student&gt; list = mapper.selectAll();        //6.处理结果        for (Student student : list) &#123;            System.out.println(student.getId() + &quot;,&quot; + student.getName() + &quot;,&quot; + student.getAge());            List&lt;Course&gt; courses = student.getCourses();            for (Course cours : courses) &#123;                System.out.println(&quot;\\t&quot; + cours);            &#125;        &#125;        //7.释放资源        sqlSession.close();        is.close();    &#125;&#125;\n\n2.4.6 多对多配置总结@Results：封装映射关系的父注解。\tResult[] value()：定义了 Result 数组@Result：封装映射关系的子注解。\tcolumn 属性：查询出的表中字段名称\tproperty 属性：实体对象中的属性名称\tjavaType 属性：被包含对象的数据类型\tmany 属性：一对多查询固定属性@Many：一对多查询的注解。\tselect 属性：指定调用某个接口中的方法\n\n\n\n三.构建sql3.1 SQL 构建对象介绍\n我们之前通过注解开发时，相关 SQL 语句都是自己直接拼写的。一些关键字写起来比较麻烦、而且容易出错。 \n MyBatis 给我们提供了 org.apache.ibatis.jdbc.SQL 功能类，专门用于构建 SQL 语句    \n\n\n3.2  查询功能的实现\n定义功能类并提供获取查询的 SQL 语句的方法。 \n\n@SelectProvider：生成查询用的 SQL 语句注解。\n type 属性：生成 SQL 语句功能类对象 \n method 属性：指定调用方法    \n\n\n3.3  新增功能的实现\n定义功能类并提供获取新增的 SQL 语句的方法。 \n\n@InsertProvider：生成新增用的 SQL 语句注解。 \ntype 属性：生成 SQL 语句功能类对象 \nmethod 属性：指定调用方法    \n\n\n3.4  修改功能的实现\n定义功能类并提供获取修改的 SQL 语句的方法。 \n\n @UpdateProvider：生成修改用的 SQL 语句注解。 \n\n\n  type 属性：生成 SQL 语句功能类对象\n   method 属性：指定调用方法    \n3.5  删除功能的实现\n定义功能类并提供获取删除的 SQL 语句的方法。 \n\n@DeleteProvider：生成删除用的 SQL 语句注解。\n type 属性：生成 SQL 语句功能类对象 \n method 属性：指定调用方法    \n\n\n四.综合案例4.1  系统介绍​         我们之前在做学生管理系统时，使用的是原始JDBC操作数据库的，操作非常麻烦，现在我们使用MyBatis操作数据库，简化Dao的开发。\n4.2  环境搭建（略）4.3  代码改造\n步骤一：新增MyBatis配置文件 MyBatisConfig.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!--MyBatis的DTD约束--&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration 核心根标签--&gt;&lt;configuration&gt;    &lt;!--引入数据库连接的配置文件--&gt;    &lt;properties resource=&quot;config.properties&quot;/&gt;    &lt;!--配置LOG4J--&gt;    &lt;settings&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;log4j&quot;/&gt;    &lt;/settings&gt;    &lt;!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;!--environment配置数据库环境  id属性唯一标识--&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;!-- dataSource数据源信息   type属性 连接池--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!-- property获取数据库连接的配置信息 --&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot; /&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot; /&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot; /&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot; /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!--配置映射关系--&gt;    &lt;mappers&gt;        &lt;package name=&quot;com.itheima&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n步骤二: 删除StudentDaoImpl，修改StudentDao\n  package com.itheima.dao;  import com.itheima.domain.Student;  import org.apache.ibatis.annotations.Delete;  import org.apache.ibatis.annotations.Insert;  import org.apache.ibatis.annotations.Select;  import org.apache.ibatis.annotations.Update;  import java.util.ArrayList;  /*      Dao层接口   */  public interface StudentDao &#123;      //查询所有学生信息      @Select(&quot;SELECT * FROM student&quot;)      public abstract ArrayList&lt;Student&gt; findAll();      //条件查询，根据id获取学生信息      @Select(&quot;SELECT * FROM student WHERE sid=#&#123;sid&#125;&quot;)      public abstract Student findById(Integer sid);            //新增学生信息      @Insert(&quot;INSERT INTO student VALUES (#&#123;sid&#125;,#&#123;name&#125;,#&#123;age&#125;,#&#123;birthday&#125;)&quot;)      public abstract int insert(Student stu);            //修改学生信息      @Update(&quot;UPDATE student SET name=#&#123;name&#125;,age=#&#123;age&#125;,birthday=#&#123;birthday&#125; WHERE sid=#&#123;sid&#125;&quot;)      public abstract int update(Student stu);            //删除学生信息      @Delete(&quot;DELETE FROM student WHERE sid=#&#123;sid&#125;&quot;)      public abstract int delete(Integer sid);  &#125;\n步骤三：修改StudentServiceImpl\npackage com.itheima.service.impl;import com.itheima.dao.StudentDao;import com.itheima.domain.Student;import com.itheima.service.StudentService;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.List;/** * 学生的业务层实现类 * @author 黑马程序员 * @Company http://www.itheima.com */public class StudentServiceImpl implements StudentService &#123;    @Override    public List&lt;Student&gt; findAll() &#123;        ArrayList&lt;Student&gt; list = null;        SqlSession sqlSession = null;        InputStream is = null;        try&#123;            //1.加载核心配置文件            is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);            //2.获取SqlSession工厂对象            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);            //3.通过工厂对象获取SqlSession对象            sqlSession = sqlSessionFactory.openSession(true);            //4.获取StudentDao接口的实现类对象            StudentDao mapper = sqlSession.getMapper(StudentDao.class);            //5.调用实现类对象的方法，接收结果            list = mapper.findAll();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //6.释放资源            if(sqlSession != null) &#123;                sqlSession.close();            &#125;            if(is != null) &#123;                try &#123;                    is.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        //7.返回结果        return list;    &#125;    @Override    public Student findById(Integer sid) &#123;        Student stu = null;        SqlSession sqlSession = null;        InputStream is = null;        try&#123;            //1.加载核心配置文件            is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);            //2.获取SqlSession工厂对象            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);            //3.通过工厂对象获取SqlSession对象            sqlSession = sqlSessionFactory.openSession(true);            //4.获取StudentDao接口的实现类对象            StudentDao mapper = sqlSession.getMapper(StudentDao.class);            //5.调用实现类对象的方法，接收结果            stu = mapper.findById(sid);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //6.释放资源            if(sqlSession != null) &#123;                sqlSession.close();            &#125;            if(is != null) &#123;                try &#123;                    is.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        //7.返回结果        return stu;    &#125;    @Override    public void save(Student student) &#123;        SqlSession sqlSession = null;        InputStream is = null;        try&#123;            //1.加载核心配置文件            is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);            //2.获取SqlSession工厂对象            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);            //3.通过工厂对象获取SqlSession对象            sqlSession = sqlSessionFactory.openSession(true);            //4.获取StudentDao接口的实现类对象            StudentDao mapper = sqlSession.getMapper(StudentDao.class);            //5.调用实现类对象的方法，接收结果            mapper.insert(student);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //6.释放资源            if(sqlSession != null) &#123;                sqlSession.close();            &#125;            if(is != null) &#123;                try &#123;                    is.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    @Override    public void update(Student student) &#123;        SqlSession sqlSession = null;        InputStream is = null;        try&#123;            //1.加载核心配置文件            is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);            //2.获取SqlSession工厂对象            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);            //3.通过工厂对象获取SqlSession对象            sqlSession = sqlSessionFactory.openSession(true);            //4.获取StudentDao接口的实现类对象            StudentDao mapper = sqlSession.getMapper(StudentDao.class);            //5.调用实现类对象的方法，接收结果            mapper.update(student);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //6.释放资源            if(sqlSession != null) &#123;                sqlSession.close();            &#125;            if(is != null) &#123;                try &#123;                    is.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    @Override    public void delete(Integer sid) &#123;        SqlSession sqlSession = null;        InputStream is = null;        try&#123;            //1.加载核心配置文件            is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);            //2.获取SqlSession工厂对象            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);            //3.通过工厂对象获取SqlSession对象            sqlSession = sqlSessionFactory.openSession(true);            //4.获取StudentDao接口的实现类对象            StudentDao mapper = sqlSession.getMapper(StudentDao.class);            //5.调用实现类对象的方法，接收结果            mapper.delete(sid);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //6.释放资源            if(sqlSession != null) &#123;                sqlSession.close();            &#125;            if(is != null) &#123;                try &#123;                    is.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;\n\n","categories":["Java基础"],"tags":["Mybaties","Java"]}]