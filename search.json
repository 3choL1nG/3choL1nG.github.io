[{"title":"Mybaties-1","url":"/2021/09/30/Mybaties-1/","content":"一.Mybatis快速入门1.1 框架介绍\n框架是一款半成品软件，我们可以基于这个半成品软件继续开发，来完成我们个性化的需求！\n\n如图:\n\n\n\n1.2 ORM介绍\nORM(Object Relational Mapping)： 对象关系映射\n\n指的是持久化数据和实体对象的映射模式，为了解决面向对象与关系型数据库存在的互不匹配的现象的技术。\n\n如图:\n\n\n具体映射关系如下图:\n\n\n\n1.3 原始jdbc操作（查询数据）\n1.4原始jdbc操作（插入数据）\n1.5 原始jdbc操作的分析\n原始 JDBC 的操作问题分析 \n​    1.频繁创建和销毁数据库的连接会造成系统资源浪费从而影响系统性能。\n\nsql 语句在代码中硬编码，如果要修改 sql 语句，就需要修改 java 代码，造成代码不易维护。\n查询操作时，需要手动将结果集中的数据封装到实体对象中。\n增删改查操作需要参数时，需要手动将实体对象的数据设置到 sql 语句的占位符。 \n\n\n原始 JDBC 的操作问题解决方案 \n​    1.使用数据库连接池初始化连接资源。 \n\n将 sql 语句抽取到配置文件中。 \n使用反射、内省等底层技术，将实体与表进行属性与字段的自动映射    \n\n\n\n1.6 什么是Mybatismybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。\nmybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。\n最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。\nMyBatis官网地址：http://www.mybatis.org/mybatis-3/ \n1.7  Mybatis的快速入门MyBatis开发步骤：\n①添加MyBatis的jar包\n②创建Student数据表\n③编写Studentr实体类 \n④编写映射文件StudentMapper.xml\n⑤编写核心文件MyBatisConfig.xml\n⑥编写测试类\n1.7.1  环境搭建1)导入MyBatis的jar包\n\nmysql-connector-java-5.1.37-bin.jar\nmybatis-3.5.3.jar\nlog4j-1.2.17.jar\n\n\n 创建student数据表\n\n\n\n编写Student实体\n\npublic class Student &#123;    private Integer id;    private String name;    private Integer age;    //省略get个set方法&#125;\n\n4)编写StudentMapper.xml映射文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!--MyBatis的DTD约束--&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--    mapper：核心根标签    namespace属性：名称空间--&gt;&lt;mapper namespace=&quot;StudentMapper&quot;&gt;    &lt;!--        select：查询功能的标签        id属性：唯一标识        resultType属性：指定结果映射对象类型        parameterType属性：指定参数映射对象类型    --&gt;    &lt;select id=&quot;selectAll&quot; resultType=&quot;student&quot;&gt;        SELECT * FROM student    &lt;/select&gt;&lt;/mapper&gt;\n\n\n编写MyBatis核心文件\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!--MyBatis的DTD约束--&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration 核心根标签--&gt;&lt;configuration&gt;    &lt;!--引入数据库连接的配置文件--&gt;    &lt;properties resource=&quot;jdbc.properties&quot;/&gt;    &lt;!--配置LOG4J--&gt;    &lt;settings&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;log4j&quot;/&gt;    &lt;/settings&gt;    &lt;!--起别名--&gt;    &lt;typeAliases&gt;        &lt;typeAlias type=&quot;com.itheima.bean.Student&quot; alias=&quot;student&quot;/&gt;        &lt;!--&lt;package name=&quot;com.itheima.bean&quot;/&gt;--&gt;    &lt;/typeAliases&gt;    &lt;!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;!--environment配置数据库环境  id属性唯一标识--&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;!-- dataSource数据源信息   type属性 连接池--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!-- property获取数据库连接的配置信息 --&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot; /&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot; /&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot; /&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot; /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!-- mappers引入映射配置文件 --&gt;    &lt;mappers&gt;        &lt;!-- mapper 引入指定的映射配置文件   resource属性指定映射配置文件的名称 --&gt;        &lt;mapper resource=&quot;StudentMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n1.7.2编写测试代码/*    控制层测试类 */public class StudentController &#123;    //创建业务层对象    private StudentService service = new StudentServiceImpl();    //查询全部功能测试    @Test    public void selectAll() &#123;        List&lt;Student&gt; students = service.selectAll();        for (Student stu : students) &#123;            System.out.println(stu);        &#125;    &#125;&#125;\n\n1.8 知识小结\n框架       \n 框架是一款半成品软件，我们可以基于框架继续开发，从而完成一些个性化的需求。\n\nORM        \n对象关系映射，数据和实体对象的映射。\n\nMyBatis       \n 是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC。\n\n\n二. MyBatis的相关api2.1 Resources\norg.apache.ibatis.io.Resources：加载资源的工具类。\n\n核心方法\n\n\n\n2.2 构建器SqlSessionFactoryBuilder\norg.apache.ibatis.session.SqlSessionFactoryBuilder：获取 SqlSessionFactory 工厂对象的功能类\n\n核心方法\n\n\n通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象\n\n\nString resource = &quot;org/mybatis/builder/mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream);\n\n其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。\n2.3 工厂对象SqlSessionFactory\norg.apache.ibatis.session.SqlSessionFactory：获取 SqlSession 构建者对象的工厂接口。\n\n核心api\n\n\n\n2.4 SqlSession会话对象\norg.apache.ibatis.session.SqlSession：构建者对象接口。用于执行 SQL、管理事务、接口代理。\n\n核心api\n\n\n\nSqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。\n三.MyBatis 映射配置文件3.1 映射配置文件介绍\n映射配置文件包含了数据和对象之间的映射关系以及要执行的 SQL 语句\n\n\n\n3.2 查询功能\n属性        \n id：唯一标识， 配合名称空间使用。     \n parameterType：指定参数映射的对象类型。       \n resultType：指定结果映射的对象类型。\n\nSQL 获取参数:        #{属性名}\n\n示例\n\n\n\n####3.3 新增功能 \n\n：新增功能标签。\n\n属性        \nid：唯一标识， 配合名称空间使用。     \nparameterType：指定参数映射的对象类型。       \nresultType：指定结果映射的对象类型。\n\nSQL 获取参数:        #{属性名}\n\n\n\n示例\n\n\n3.4 修改功能\n属性        \nid：唯一标识， 配合名称空间使用。     \nparameterType：指定参数映射的对象类型。       \nresultType：指定结果映射的对象类型。\n\nSQL 获取参数:        #{属性名}\n\n\n\n示例\n\n\n3.5 删除功能\n：查询功能标签。\n\n属性        \nid：唯一标识， 配合名称空间使用。     \nparameterType：指定参数映射的对象类型。       \nresultType：指定结果映射的对象类型。\n\nSQL 获取参数:        #{属性名}\n\n\n\n示例\n\n\n总结： 大家可以发现crud操作，除了标签名称以及sql语句不一样之外，其他属性参数基本一致。\n\n\n3.6 映射配置文件小结\n四.Mybatis核心配置文件介绍4.1 核心配置文件介绍核心配置文件包含了 MyBatis 最核心的设置和属性信息。如数据库的连接、事务、连接池信息等。\n如下图:\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!--MyBatis的DTD约束--&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration 核心根标签--&gt;&lt;configuration&gt;    &lt;!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;!--environment配置数据库环境  id属性唯一标识--&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;!-- dataSource数据源信息   type属性 连接池--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!-- property获取数据库连接的配置信息 --&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///db1&quot; /&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!-- mappers引入映射配置文件 --&gt;    &lt;mappers&gt;        &lt;!-- mapper 引入指定的映射配置文件   resource属性指定映射配置文件的名称 --&gt;        &lt;mapper resource=&quot;StudentMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n4.2 数据库连接配置文件引入\nproperties标签引入外部文件\n&lt;!--引入数据库连接的配置文件--&gt;&lt;properties resource=&quot;jdbc.properties&quot;/&gt;\n具体使用，如下配置\n&lt;!-- property获取数据库连接的配置信息 --&gt;  &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot; /&gt;  &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot; /&gt;  &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot; /&gt;  &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot; /&gt;\n\n4.3 起别名\n：为全类名起别名的父标签。\n\n：为全类名起别名的子标签。\n\n属性      \n type：指定全类名      \n alias：指定别名\n\n：为指定包下所有类起别名的子标签。(别名就是类名)\n\n如下图：\n\n\n具体如下配置\n&lt;!--起别名--&gt;&lt;typeAliases&gt;    &lt;typeAlias type=&quot;com.itheima.bean.Student&quot; alias=&quot;student&quot;/&gt;    &lt;!--&lt;package name=&quot;com.itheima.bean&quot;/&gt;--&gt;&lt;/typeAliase\n\n4.4 总结\n五.Mybatis传统方式开发5.1 Dao 层传统实现方式\n分层思想：控制层(controller)、业务层(service)、持久层(dao)。\n\n调用流程\n\n\n\n5.2 LOG4J的配置和使用\n在日常开发过程中，排查问题时难免需要输出 MyBatis 真正执行的 SQL 语句、参数、结果等信息，我们就可以借助 LOG4J 的功能来实现执行信息的输出。\n\n使用步骤：\n\n\n\n","categories":["Java基础"],"tags":["Mybaties","Java"]},{"title":"Springboot","url":"/2021/09/30/Springboot/","content":"01-今日内容\nSpring概述、快速入门\nSpringBoot配置\nSpringBoot整合\n\n02-SpringBoot概述 SpringBoot提供了一种快速使用Spring的方式，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率\nSpringBoot功能\n 1） 自动配置\nSpring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是SpringBoot自动完成的。\n2） 起步依赖\n起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。\n简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。\n3） 辅助功能\n提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等。\n注意：Spring Boot 并不是对 Spring 功能上的增强，而是提供了一种快速使用 Spring 的方式。\n03-SpringBoot快速入门 需求：搭建SpringBoot工程，定义HelloController.hello()方法，返回”Hello SpringBoot!”。\n实现步骤：\n①创建Maven项目\n②导入SpringBoot起步依赖\n&lt;!--springboot工程需要继承的父工程--&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.8.RELEASE&lt;/version&gt;    &lt;/parent&gt;    &lt;dependencies&gt;        &lt;!--web开发的起步依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\n\n③定义Controller\n@RestControllerpublic class HelloController &#123;    @RequestMapping(&quot;/hello&quot;)    public String hello()&#123;        return &quot; hello Spring Boot !&quot;;    &#125;&#125;\n\n④编写引导类\n/** * 引导类。 SpringBoot项目的入口 */@SpringBootApplicationpublic class HelloApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(HelloApplication.class,args);    &#125;&#125;\n\n⑤启动测试\n04-快速构建SpringBoot工程\n\n\n05-SpringBoot起步依赖原理分析\n在spring-boot-starter-parent中定义了各种技术的版本信息，组合了一套最优搭配的技术版本。\n\n在各种starter中，定义了完成该功能需要的坐标合集，其中大部分版本信息来自于父工程。\n\n我们的工程继承parent，引入starter后，通过依赖传递，就可以简单方便获得需要的jar包，并且不会存在版本冲突等问题。\n\n\n06-SpringBoot配置-配置文件分类SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml（application.yaml）进行配置。\n\n默认配置文件名称：application\n\n在同一级目录下优先级为：properties&gt;yml &gt; yaml\n\n\n例如：配置内置Tomcat的端口\nproperties：\nserver.port=8080\n\nyml:\nserver: port: 8080\n\n07-SpringBoot配置-yaml基本语法\n大小写敏感\n数据值前边必须有空格，作为分隔符\n使用缩进表示层级关系\n缩进时不允许使用Tab键，只允许使用空格（各个系统 Tab对应的 空格数目可能不同，导致层次混乱）。\n缩进的空格数目不重要，只要相同层级的元素左侧对齐即可\n‘’#” 表示注释，从这个字符一直到行尾，都会被解析器忽略。\n\nserver: \tport: 8080      address: 127.0.0.1name: abc\n\n08-SpringBoot配置-yaml数据格式**对象(map)**：键值对的集合。\nperson:     name: zhangsan# 行内写法person: &#123;name: zhangsan&#125;\n\n数组：一组按次序排列的值\naddress:  - beijing  - shanghai# 行内写法address: [beijing,shanghai]\n\n纯量：单个的、不可再分的值\nmsg1: &#x27;hello \\n world&#x27;  # 单引忽略转义字符msg2: &quot;hello \\n world&quot;  # 双引识别转义字符\n\n参数引用\nname: lisi person:  name: $&#123;name&#125; # 引用上边定义的name值\n\n09-SpringBoot配置-获取数据_1@Value\n#获取普通配置@Value(&quot;$&#123;name&#125;&quot;) private String name; #获取对象属性 @Value(&quot;$&#123;person.name&#125;&quot;) private String name2;\t#获取数组 @Value(&quot;$&#123;address[0]&#125;&quot;) private String address1;#获取纯量 @Value(&quot;$&#123;msg1&#125;&quot;) private String msg1;\n\nEvironment\n@Autowired private Environment env;System.out.println(env.getProperty(&quot;person.name&quot;)); System.out.println(env.getProperty(&quot;address[0]&quot;));\n\n10-SpringBoot配置-获取数据_2 @ConfigurationProperties \n注意：prefix一定要写\n@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123;    private String name;    private int age;    private String[] address;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String[] getAddress() &#123;        return address;    &#125;    public void setAddress(String[] address) &#123;        this.address = address;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n11-SpringBoot配置-profile\n profile是用来完成不同环境下，配置动态切换功能的。\n\n profile配置方式\n\n\n   ​    多profile文件方式：提供多个配置文件，每个代表一种环境。\n   ​        application-dev.properties/yml 开发环境\n   ​        application-test.properties/yml 测试环境\n   ​        application-pro.properties/yml 生产环境\n   ​    yml多文档方式：\n​                在yml中使用  — 分隔不同配置\n\n profile激活方式\n\n\n配置文件： 再配置文件中配置：spring.profiles.active=dev\n虚拟机参数：在VM options 指定：-Dspring.profiles.active=dev\n命令行参数：java –jar xxx.jar  –spring.profiles.active=dev\n\n12-SpringBoot配置-项目内部配置文件加载顺序 加载顺序为上文的排列顺序，高优先级配置的属性会生效\n\nfile:./config/：当前项目下的/config目录下\nfile:./           ：当前项目的根目录\nclasspath:/config/：classpath的/config目录\nclasspath:/  ：classpath的根目录\n\n13-SpringBoot配置-项目外部配置加载顺序 外部配置文件的使用是为了对能不文件的配合\n1.命令行\njava -jar app.jar --name=&quot;Spring“ --server.port=9000\n\n2.指定配置文件位置\njava -jar myproject.jar --spring.config.location=e://application.properties\n\n3.外部不带profile的properties文件\nclasspath:/config/application.propertiesclasspath:/application.properties\n\n\n https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config\n\n14-SpringBoot整合Junit\n搭建SpringBoot工程\n\n 引入starter-test起步依赖\n\n\n&lt;dependencies&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;           &lt;scope&gt;test&lt;/scope&gt;       &lt;/dependency&gt;   &lt;/dependencies&gt;\n\n\n编写测试类\n\n/** * 测试类 */@RunWith(SpringRunner.class)@SpringBootTest(classes = SpringbootJunitApplication.class )public class UserServiceTest &#123;    @Test    public void test()&#123;        System.out.println(111);    &#125;&#125;\n\n4.测试\n15-SpringBoot整合mybatis①搭建SpringBoot工程\n②引入mybatis起步依赖，添加mysql驱动\n&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.1.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;!--&lt;scope&gt;runtime&lt;/scope&gt;--&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\n\n③编写DataSource和MyBatis相关配置\napplication.yml\n# datasourcespring:  datasource:    url: jdbc:mysql:///springboot?serverTimezone=UTC    username: root    password: root    driver-class-name: com.mysql.cj.jdbc.Driver# mybatismybatis:  mapper-locations: classpath:mapper/*Mapper.xml # mapper映射文件路径  type-aliases-package: com.itheima.springbootmybatis.domain  # config-location:  # 指定mybatis的核心配置文件\n\n④定义表和实体类\npublic class User &#123;    private int id;    private String username;    private String password;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; +                &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n⑤编写dao和mapper文件/纯注解开发\n编写dao\n@Mapper@Repositorypublic interface UserXmlMapper &#123;    public List&lt;User&gt; findAll();&#125;\n\nmapper.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.springbootmybatis.mapper.UserXmlMapper&quot;&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt;        select * from t_user    &lt;/select&gt;&lt;/mapper&gt;\n\n纯注解开发\n@Mapper@Repositorypublic interface UserMapper &#123;    @Select(&quot;select * from t_user&quot;)    public List&lt;User&gt; findAll();&#125;\n\n⑥测试\n16-SpringBoot整合redis①搭建SpringBoot工程\n②引入redis起步依赖\n&lt;dependencies&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;          &lt;scope&gt;test&lt;/scope&gt;      &lt;/dependency&gt;  &lt;/dependencies&gt;\n\n③配置redis相关属性\nspring:  redis:    host: 127.0.0.1 # redis的主机ip    port: 6379\n\n④注入RedisTemplate模板\n⑤编写测试方法，测试\n@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootRedisApplicationTests &#123;    @Autowired    private RedisTemplate redisTemplate;    @Test    public void testSet() &#123;        //存入数据        redisTemplate.boundValueOps(&quot;name&quot;).set(&quot;zhangsan&quot;);    &#125;    @Test    public void testGet() &#123;        //获取数据        Object name = redisTemplate.boundValueOps(&quot;name&quot;).get();        System.out.println(name);    &#125;&#125;\n","categories":["Java基础"],"tags":["Java","Springboot"]},{"title":"Springboot高级","url":"/2021/09/30/SpringBoot%E9%AB%98%E7%BA%A7/","content":"01-SpringBoot高级-今日内容\n SpringBoot自定配置\nSpringBoot事件监听\nSpringBoot流程分析\nSpringBoot监控\nSpringBoot部署\n\n02-SpringBoot自动配置-Condition-1 Condition是Spring4.0后引入的条件化配置接口，通过实现Condition接口可以完成有条件的加载相应的Bean\n@Conditional要配和Condition的实现类（ClassCondition）进行使用\n\nClassCondition\n\npublic class ClassCondition implements Condition &#123;    /**     *     * @param context 上下文对象。用于获取环境，IOC容器，ClassLoader对象     * @param metadata 注解元对象。 可以用于获取注解定义的属性值     * @return     */    @Override    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;              //1.需求： 导入Jedis坐标后创建Bean        //思路：判断redis.clients.jedis.Jedis.class文件是否存在        boolean flag = true;        try &#123;            Class&lt;?&gt; cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);        &#125; catch (ClassNotFoundException e) &#123;            flag = false;        &#125;        return flag;          &#125;&#125;\n\n\nUserConfig\n\n@Configurationpublic class UserConfig &#123;    @Bean    @Conditional(ClassCondition.class)    public User user()&#123;        return new User();    &#125;&#125;\n\n测试\n@SpringBootApplicationpublic class SpringbootConditionApplication &#123;    public static void main(String[] args) &#123;        //启动SpringBoot的应用，返回Spring的IOC容器        ConfigurableApplicationContext context = SpringApplication.run(SpringbootConditionApplication.class, args);        Object user = context.getBean(&quot;user&quot;);        System.out.println(user);    &#125;&#125;\n\n03-SpringBoot自动配置-Condition-2 需求：将类的判断定义为动态的。判断哪个字节码文件存在可以动态指定。\n自定义条件注解类\nimport org.springframework.context.annotation.Conditional;import java.lang.annotation.*;@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(ClassCondition.class)public @interface ConditionOnClass &#123;    String[] value();&#125;\n\n注意：此处@ConditionOnClass为自定义注解\n@Configurationpublic class UserConfig &#123;    @Bean    //@Conditional(ClassCondition.class)    @ConditionOnClass(&quot;com.alibaba.fastjson.JSON&quot;)    public User user()&#123;        return new User();    &#125;    @Bean    @ConditionalOnProperty(name = &quot;itcast&quot;,havingValue = &quot;itheima&quot;)    public User user2()&#123;        return new User();    &#125;&#125;\n\n测试User对象的创建\n@SpringBootApplicationpublic class SpringbootConditionApplication &#123;    public static void main(String[] args) &#123;        //启动SpringBoot的应用，返回Spring的IOC容器        ConfigurableApplicationContext context = SpringApplication.run(SpringbootConditionApplication.class, args);        Object user = context.getBean(&quot;user&quot;);        System.out.println(user);    &#125;&#125;\n\n查看条件注解源码\n\nSpringBoot 提供的常用条件注解：\nConditionalOnProperty：判断配置文件中是否有对应属性和值才初始化Bean\nConditionalOnClass：判断环境中是否有对应字节码文件才初始化Bean\nConditionalOnMissingBean：判断环境中没有对应Bean才初始化Bean\n04-SpringBoot自动配置-切换内置web服务器查看继承关系图\n\n排除Tomcat\n\npom文件中的排除依赖效果\n&lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;           &lt;!--排除tomcat依赖--&gt;           &lt;exclusions&gt;               &lt;exclusion&gt;                   &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;                   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;               &lt;/exclusion&gt;           &lt;/exclusions&gt;       &lt;/dependency&gt;       &lt;!--引入jetty的依赖--&gt;       &lt;dependency&gt;           &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;       &lt;/dependency&gt;\n\n05-SpringBoot自动配置-Enable注解原理\nSpringBoot不能直接获取在其他工程中定义的Bean\n演示代码：\nspringboot-enable工程\n/** * @ComponentScan 扫描范围：当前引导类所在包及其子包 * * com.itheima.springbootenable * com.itheima.config * //1.使用@ComponentScan扫描com.itheima.config包 * //2.可以使用@Import注解，加载类。这些类都会被Spring创建，并放入IOC容器 * //3.可以对Import注解进行封装。 *///@ComponentScan(&quot;com.itheima.config&quot;)//@Import(UserConfig.class)@EnableUser@SpringBootApplicationpublic class SpringbootEnableApplication &#123;    public static void main(String[] args) &#123;        ConfigurableApplicationContext context = SpringApplication.run(SpringbootEnableApplication.class, args);     //获取Bean        Object user = context.getBean(&quot;user&quot;);        System.out.println(user);\t&#125;&#125;\n\npom中引入springboot-enable-other\n   &lt;dependency&gt;\n         &lt;groupId&gt;com.itheima&lt;/groupId&gt;\n       &lt;artifactId&gt;springboot-enable-other&lt;/artifactId&gt;\n         &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n   &lt;/dependency&gt;\n\nspringboot-enable-other工程**UserConfig**```java@Configurationpublic class UserConfig &#123;    @Bean  public User user() &#123;        return new User();  &#125; &#125;\n\nEnableUser注解类\n  import org.springframework.context.annotation.Import;    import java.lang.annotation.*;    @Target(ElementType.TYPE)  @Retention(RetentionPolicy.RUNTIME)@Documented  @Import(UserConfig.class)public @interface EnableUser &#123;  &#125;  \n\n原因：@ComponentScan 扫描范围：当前引导类所在包及其子包\n三种解决方案：\n1.使用@ComponentScan扫描com.itheima.config包 \n2.可以使用@Import注解，加载类。这些类都会被Spring创建，并放入IOC容器\n3.可以对Import注解进行封装。\n重点：Enable注解底层原理是使用@Import注解实现Bean的动态加载\n\n\n06-SpringBoot自动配置-@Import详解@Enable*底层依赖于@Import注解导入一些类，使用@Import导入的类会被Spring加载到IOC容器中。而@Import提供4中用法：\n①导入Bean\n②导入配置类\n③导入 ImportSelector 实现类。一般用于加载配置文件中的类\n④导入 ImportBeanDefinitionRegistrar 实现类。\n\n导入Bean  @Import(User.class)\n\n导入配置类  @Import(UserConfig.class)\n\n导入 ImportSelector 实现类   @Import(MyImportSelector.class)\nMyImportSelector\npublic class MyImportSelector implements ImportSelector &#123;    @Override    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;        return new String[]&#123;&quot;com.itheima.domain.User&quot;, &quot;com.itheima.domain.Role&quot;&#125;;    &#125;&#125;\n导入 ImportBeanDefinitionRegistrar 实现类。@Import({MyImportBeanDefinitionRegistrar.class})\npublic class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;    @Override    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(User.class).getBeanDefinition();        registry.registerBeanDefinition(&quot;user&quot;, beanDefinition);    &#125;&#125;\n\nSpringbootEnableApplication测试代码\n  /*** Import4中用法：  *  1. 导入Bean  *  2. 导入配置类  *  3. 导入ImportSelector的实现类。  *  4. 导入ImportBeanDefinitionRegistrar实现类  */ //@Import(User.class) //@Import(UserConfig.class) //@Import(MyImportSelector.class) //@Import(&#123;MyImportBeanDefinitionRegistrar.class&#125;) @SpringBootApplication public class SpringbootEnableApplication &#123;     public static void main(String[] args) &#123;         ConfigurableApplicationContext context = SpringApplication.run(SpringbootEnableApplication.class, args);              /*//获取Bean         Object user = context.getBean(&quot;user&quot;);         System.out.println(user);*/              /*User user = context.getBean(User.class);         System.out.println(user);              Role role = context.getBean(Role.class);         System.out.println(role);*/            /*  Object user = context.getBean(&quot;user&quot;);         System.out.println(user);*/      Map&lt;String, User&gt; map = context.getBeansOfType(User.class);         System.out.println(map);          &#125; &#125;\n\n@EnableAutoConfiguration中使用的是第三种方式：@Import(AutoConfigurationImportSelector.class)\n07-SpringBoot自动配置-@EnableAutoConfiguration详解\n\n@EnableAutoConfiguration 注解内部使用 @Import(AutoConfigurationImportSelector.class)来加载配置类。 \n\n配置文件位置：META-INF/spring.factories，该配置文件中定义了大量的配置类，当 SpringBoot 应用启动时，会自动加载这些配置类，初始化Bean\n\n并不是所有的Bean都会被初始化，在配置类中使用Condition来加载满足条件的Bean\n\n\n08-SpringBoot自动配置-自定义starter步骤分析需求：自定义redis-starter。要求当导入redis坐标时，SpringBoot自动创建Jedis的Bean。\n步骤：\n①创建 redis-spring-boot-autoconfigure 模块\n②创建 redis-spring-boot-starter 模块,依赖 redis-spring-boot-autoconfigure的模块\n③在 redis-spring-boot-autoconfigure 模块中初始化 Jedis 的 Bean。并定义META-INF/spring.factories 文件\n④在测试模块中引入自定义的 redis-starter 依赖，测试获取 Jedis 的Bean，操作 redis。\n09-SpringBoot自动配置-自定义starter实现-1\n创建redis-spring-boot-starter工程\n\n​         pom文件中引入redis-spring-boot-autoconfigure\n&lt;!--引入configure--&gt;       &lt;dependency&gt;           &lt;groupId&gt;com.itheima&lt;/groupId&gt;           &lt;artifactId&gt;redis-spring-boot-autoconfigure&lt;/artifactId&gt;           &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;       &lt;/dependency&gt;\n\n\n创建redis-spring-boot-autoconfigure配置工程  \n\n创建RedisProperties配置文件参数绑定类 \n@ConfigurationProperties(prefix = &quot;redis&quot;)public class RedisProperties &#123;    private String host = &quot;localhost&quot;;    private int port = 6379;    public String getHost() &#123;        return host;    &#125;    public void setHost(String host) &#123;        this.host = host;    &#125;    public int getPort() &#123;        return port;    &#125;    public void setPort(int port) &#123;        this.port = port;    &#125;&#125;\n\n 创建RedisAutoConfiguration自动配置类\n@Configuration@EnableConfigurationProperties(RedisProperties.class)public class RedisAutoConfiguration &#123;    /**     * 提供Jedis的bean     */    @Bean    public Jedis jedis(RedisProperties redisProperties) &#123;               return new Jedis(redisProperties.getHost(), redisProperties.getPort());    &#125;&#125;\n\n\n\n在resource目录下创建META-INF文件夹并创建spring.factories\n注意：”\\ “是换行使用的\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\  com.itheima.redis.config.RedisAutoConfiguration\n\n\n在springboot-enable工程中引入自定义的redis的starter\n\n&lt;!--自定义的redis的starter--&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.itheima&lt;/groupId&gt;          &lt;artifactId&gt;redis-spring-boot-starter&lt;/artifactId&gt;          &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;      &lt;/dependency&gt;\n\n在SpringbootEnableApplication启动类中测试\nJedis jedis = context.getBean(Jedis.class);       System.out.println(jedis);\n\n10-SpringBoot自动配置-自定义starter实现-2测试springboot-enable工程中的application.properties中的配置参数\nredis.port=6666\n\n使用注解完成有条件加载配置类\n@Configuration@EnableConfigurationProperties(RedisProperties.class)@ConditionalOnClass(Jedis.class)public class RedisAutoConfiguration &#123;    /**     * 提供Jedis的bean     */    @Bean    @ConditionalOnMissingBean(name = &quot;jedis&quot;)    public Jedis jedis(RedisProperties redisProperties) &#123;        System.out.println(&quot;RedisAutoConfiguration....&quot;);        return new Jedis(redisProperties.getHost(), redisProperties.getPort());    &#125;&#125;\n\n11-SpringBoot事件监听 Java中的事件监听机制定义了以下几个角色：\n①事件：Event，继承 java.util.EventObject 类的对象\n②事件源：Source ，任意对象Object\n③监听器：Listener，实现 java.util.EventListener 接口 的对象\nSpringBoot 在项目启动时，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成一些操作。\n\nApplicationContextInitializer、\n\nSpringApplicationRunListener、\n\nCommandLineRunner、\n\nApplicationRunner\n自定义监听器的启动时机：MyApplicationRunner和MyCommandLineRunner都是当项目启动后执行，使用@Component放入容器即可使用\n\n\nMyApplicationRunner\n/** * 当项目启动后执行run方法。 */@Componentpublic class MyApplicationRunner implements ApplicationRunner &#123;    @Override    public void run(ApplicationArguments args) throws Exception &#123;        System.out.println(&quot;ApplicationRunner...run&quot;);        System.out.println(Arrays.asList(args.getSourceArgs()));    &#125;&#125; \n\n MyCommandLineRunner\n@Componentpublic class MyCommandLineRunner implements CommandLineRunner &#123;    @Override    public void run(String... args) throws Exception &#123;        System.out.println(&quot;CommandLineRunner...run&quot;);        System.out.println(Arrays.asList(args));    &#125;&#125;\n\n\n\nMyApplicationContextInitializer的使用要在resource文件夹下添加META-INF/spring.factories\norg.springframework.context.ApplicationContextInitializer=com.itheima.springbootlistener.listener.MyApplicationContextInitializer\n\n@Componentpublic class MyApplicationContextInitializer implements ApplicationContextInitializer &#123;    @Override    public void initialize(ConfigurableApplicationContext applicationContext) &#123;        System.out.println(&quot;ApplicationContextInitializer....initialize&quot;);    &#125;&#125;\n\nMySpringApplicationRunListener的使用要添加构造器\npublic class MySpringApplicationRunListener implements SpringApplicationRunListener &#123;    public MySpringApplicationRunListener(SpringApplication application, String[] args) &#123;    &#125;    @Override    public void starting() &#123;        System.out.println(&quot;starting...项目启动中&quot;);    &#125;    @Override    public void environmentPrepared(ConfigurableEnvironment environment) &#123;        System.out.println(&quot;environmentPrepared...环境对象开始准备&quot;);    &#125;    @Override    public void contextPrepared(ConfigurableApplicationContext context) &#123;        System.out.println(&quot;contextPrepared...上下文对象开始准备&quot;);    &#125;    @Override    public void contextLoaded(ConfigurableApplicationContext context) &#123;        System.out.println(&quot;contextLoaded...上下文对象开始加载&quot;);    &#125;    @Override    public void started(ConfigurableApplicationContext context) &#123;        System.out.println(&quot;started...上下文对象加载完成&quot;);    &#125;    @Override    public void running(ConfigurableApplicationContext context) &#123;        System.out.println(&quot;running...项目启动完成，开始运行&quot;);    &#125;    @Override    public void failed(ConfigurableApplicationContext context, Throwable exception) &#123;        System.out.println(&quot;failed...项目启动失败&quot;);    &#125;&#125;\n\n12-SpringBoot流程分析-初始化\n 配置启动引导类（判断是否有启动主类）\n\n判断是否是Web环境\n\n获取初始化类、监听器类\n\n\n\n13-SpringBoot流程分析-run\n启动计时器\n\n执行监听器\n\n准备环境\n\n 打印banner：可以resource下粘贴自定义的banner\n\n创建context\nrefreshContext(context);\n\n执行refreshContext方法后才真正创建Bean\n\n\n\n14-SpringBoot监控-actuator基本使用 ①导入依赖坐标\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n②访问http://localhost:8080/acruator\n&#123;    &quot;_links&quot;:&#123;        &quot;self&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator&quot;,            &quot;templated&quot;:false        &#125;,        &quot;health&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/health&quot;,            &quot;templated&quot;:false        &#125;,        &quot;health-component-instance&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/health/&#123;component&#125;/&#123;instance&#125;&quot;,            &quot;templated&quot;:true        &#125;,        &quot;health-component&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/health/&#123;component&#125;&quot;,            &quot;templated&quot;:true        &#125;,        &quot;info&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/info&quot;,            &quot;templated&quot;:false        &#125;    &#125;&#125;\n\nhttp://localhost:8080/actuator/info\n在application.properties中配置\ninfo.name=lucyinfo.age=99\n\nhttp://localhost:8080/actuator/health\n开启健康检查详细信息\nmanagement.endpoint.health.show-details=always\n\n&#123;    &quot;status&quot;:&quot;UP&quot;,    &quot;details&quot;:&#123;        &quot;diskSpace&quot;:&#123;            &quot;status&quot;:&quot;UP&quot;,            &quot;details&quot;:&#123;                &quot;total&quot;:159579508736,                &quot;free&quot;:13558104064,                &quot;threshold&quot;:10485760            &#125;        &#125;,        &quot;redis&quot;:&#123;            &quot;status&quot;:&quot;UP&quot;,            &quot;details&quot;:&#123;                &quot;version&quot;:&quot;2.4.5&quot;            &#125;        &#125;    &#125;&#125;\n\n15-SpringBoot监控-actuator开启所有endpoint 开启所有endpoint\n在application.properties中配置：\nmanagement.endpoints.web.exposure.include=*\n\n开启所有endpoint的返回结果：\n&#123;    &quot;_links&quot;:&#123;        &quot;self&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator&quot;,            &quot;templated&quot;:false        &#125;,        &quot;auditevents&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/auditevents&quot;,            &quot;templated&quot;:false        &#125;,        &quot;beans&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/beans&quot;,            &quot;templated&quot;:false        &#125;,        &quot;caches-cache&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/caches/&#123;cache&#125;&quot;,            &quot;templated&quot;:true        &#125;,        &quot;caches&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/caches&quot;,            &quot;templated&quot;:false        &#125;,        &quot;health-component-instance&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/health/&#123;component&#125;/&#123;instance&#125;&quot;,            &quot;templated&quot;:true        &#125;,        &quot;health&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/health&quot;,            &quot;templated&quot;:false        &#125;,        &quot;health-component&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/health/&#123;component&#125;&quot;,            &quot;templated&quot;:true        &#125;,        &quot;conditions&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/conditions&quot;,            &quot;templated&quot;:false        &#125;,        &quot;configprops&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/configprops&quot;,            &quot;templated&quot;:false        &#125;,        &quot;env&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/env&quot;,            &quot;templated&quot;:false        &#125;,        &quot;env-toMatch&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/env/&#123;toMatch&#125;&quot;,            &quot;templated&quot;:true        &#125;,        &quot;info&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/info&quot;,            &quot;templated&quot;:false        &#125;,        &quot;loggers&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/loggers&quot;,            &quot;templated&quot;:false        &#125;,        &quot;loggers-name&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/loggers/&#123;name&#125;&quot;,            &quot;templated&quot;:true        &#125;,        &quot;heapdump&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/heapdump&quot;,            &quot;templated&quot;:false        &#125;,        &quot;threaddump&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/threaddump&quot;,            &quot;templated&quot;:false        &#125;,        &quot;metrics-requiredMetricName&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/metrics/&#123;requiredMetricName&#125;&quot;,            &quot;templated&quot;:true        &#125;,        &quot;metrics&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/metrics&quot;,            &quot;templated&quot;:false        &#125;,        &quot;scheduledtasks&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/scheduledtasks&quot;,            &quot;templated&quot;:false        &#125;,        &quot;httptrace&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/httptrace&quot;,            &quot;templated&quot;:false        &#125;,        &quot;mappings&quot;:&#123;            &quot;href&quot;:&quot;http://localhost:8080/actuator/mappings&quot;,            &quot;templated&quot;:false        &#125;    &#125;&#125;\n\n16-SpringBoot监控-springboot admin图形化界面使用SpringBoot Admin 有两个角色，客户端(Client)和服务端(Server)。\n以下为创建服务端和客户端工程步骤：\nadmin-server：\n①创建 admin-server 模块\n②导入依赖坐标 admin-starter-server\n\n&lt;dependency&gt;      &lt;groupId&gt;de.codecentric&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;  &lt;/dependency&gt;\n\n③在引导类上启用监控功能@EnableAdminServer\n@EnableAdminServer@SpringBootApplicationpublic class SpringbootAdminServerApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringbootAdminServerApplication.class, args);    &#125;&#125;\n\n\n\nadmin-client：\n①创建 admin-client 模块\n②导入依赖坐标 admin-starter-client\n&lt;dependency&gt;        &lt;groupId&gt;de.codecentric&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;    &lt;/dependency&gt;\n\n③配置相关信息：server地址等\n# 执行admin.server地址spring.boot.admin.client.url=http://localhost:9000management.endpoint.health.show-details=alwaysmanagement.endpoints.web.exposure.include=*\n\n④启动server和client服务，访问server\n17-SpringBoot部署 SpringBoot 项目开发完毕后，支持两种方式部署到服务器：\n①jar包(官方推荐)\n②war包\n更改pom文件中的打包方式为war\n修改启动类\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;@SpringBootApplicationpublic class SpringbootDeployApplication extends SpringBootServletInitializer &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringbootDeployApplication.class, args);    &#125;    @Override    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;        return builder.sources(SpringbootDeployApplication.class);    &#125;&#125;\n\n\n\n指定打包的名称\n&lt;build&gt;       &lt;finalName&gt;springboot&lt;/finalName&gt;       &lt;plugins&gt;           &lt;plugin&gt;               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;               &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;           &lt;/plugin&gt;       &lt;/plugins&gt;   &lt;/build&gt;\n\n","categories":["Java基础"],"tags":["Java","Springboot"]},{"title":"Mybaties-2","url":"/2021/09/30/mybatis-2/","content":"一.接口代理方式实现Dao1.1 代理开发方式介绍​    采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。\nMapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。\nMapper 接口开发需要遵循以下规范：\n1) Mapper.xml文件中的namespace与mapper接口的全限定名相同\n2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同\n3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同\n4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同\n总结: \n接口开发的方式: 程序员只需定义接口,就可以对数据库进行操作,那么具体的对象怎么创建?\n1.程序员负责定义接口\n2.在操作数据库,mybatis框架根据接口,通过动态代理的方式生成代理对象,负责数据库的crud操作\n1.2.编写StudentMapper接口\n1.3 测试代理方式public Student selectById(Integer id) &#123;       Student stu = null;       SqlSession sqlSession = null;       InputStream is = null;       try&#123;           //1.加载核心配置文件           is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);           //2.获取SqlSession工厂对象           SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);           //3.通过工厂对象获取SqlSession对象           sqlSession = sqlSessionFactory.openSession(true);           //4.获取StudentMapper接口的实现类对象           StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); // StudentMapper mapper = new StudentMapperImpl();           //5.通过实现类对象调用方法，接收结果           stu = mapper.selectById(id);       &#125; catch (Exception e) &#123;       &#125; finally &#123;           //6.释放资源           if(sqlSession != null) &#123;               sqlSession.close();           &#125;           if(is != null) &#123;               try &#123;                   is.close();               &#125; catch (IOException e) &#123;                   e.printStackTrace();               &#125;           &#125;       &#125;       //7.返回结果       return stu;   &#125;\n\n1.4 源码分析\n分析动态代理对象如何生成的？ \n通过动态代理开发模式，我们只编写一个接口，不写实现类，我们通过 getMapper() 方法最终获取到 org.apache.ibatis.binding.MapperProxy 代理对象，然后执行功能，而这个代理对象正是 MyBatis 使用了 JDK 的动态代理技术，帮助我们生成了代理实现类对象。从而可以进行相关持久化操作。 \n\n分析方法是如何执行的？\n 动态代理实现类对象在执行方法的时候最终调用了 mapperMethod.execute() 方法，这个方法中通过 switch 语句根据操作类型来判断是新增、修改、删除、查询操作，最后一步回到了 MyBatis 最原生的 SqlSession 方式来执行增删改查。    \n\n\n1.5 知识小结 接口代理方式可以让我们只编写接口即可，而实现类对象由 MyBatis 生成。 \n 实现规则 ：\n\n映射配置文件中的名称空间必须和 Dao 层接口的全类名相同。\n映射配置文件中的增删改查标签的 id 属性必须和 Dao 层接口的方法名相同。 \n映射配置文件中的增删改查标签的 parameterType 属性必须和 Dao 层接口方法的参数相同。 \n映射配置文件中的增删改查标签的 resultType 属性必须和 Dao 层接口方法的返回值相同。 \n获取动态代理对象 SqlSession 功能类中的 getMapper() 方法。    \n\n二. 动态sql语句2.1 动态sql语句概述​    Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。\n参考的官方文档，描述如下：\n\n2.2 动态 SQL  之&lt;if&gt;我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。\n如下图：\n&lt;select id=&quot;findByCondition&quot; parameterType=&quot;student&quot; resultType=&quot;student&quot;&gt;    select * from student    &lt;where&gt;        &lt;if test=&quot;id!=0&quot;&gt;            and id=#&#123;id&#125;        &lt;/if&gt;        &lt;if test=&quot;username!=null&quot;&gt;            and username=#&#123;username&#125;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;\n\n当查询条件id和username都存在时，控制台打印的sql语句如下：\n … … … //获得MyBatis框架生成的StudentMapper接口的实现类StudentMapper mapper = sqlSession.getMapper( StudentMapper.class);Student condition = new Student();condition.setId(1);condition.setUsername(&quot;lucy&quot;);Student student = mapper.findByCondition(condition);… … …\n\n\n当查询条件只有id存在时，控制台打印的sql语句如下：\n … … … //获得MyBatis框架生成的UserMapper接口的实现类 StudentMapper mapper = sqlSession.getMapper( StudentMapper.class);    Student condition = new Student();    condition.setId(1);    Student student = mapper.findByCondition(condition);… … …\n\n\n总结语法:\n&lt;where&gt;：条件标签。如果有动态条件，则使用该标签代替 where 关键字。&lt;if&gt;：条件判断标签。&lt;if test=“条件判断”&gt;\t查询条件拼接&lt;/if&gt;\n\n\n\n2.3  动态 SQL  之&lt;foreach&gt;循环执行sql的拼接操作，例如：SELECT * FROM student  WHERE id IN (1,2,5)。\n &lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;student&quot;&gt;    select * from student    &lt;where&gt;        &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;            #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n测试代码片段如下：\n … … … //获得MyBatis框架生成的UserMapper接口的实现类StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);int[] ids = new int[]&#123;2,5&#125;;List&lt;Student&gt; sList = mapper.findByIds(ids);System.out.println(sList);… … …\n\n总结语法:\n&lt;foreach&gt;：循环遍历标签。适用于多个参数或者的关系。    &lt;foreach collection=“”open=“”close=“”item=“”separator=“”&gt;\t\t获取参数\t&lt;/foreach&gt;\n\n属性collection：参数容器类型， (list-集合， array-数组)。open：开始的 SQL 语句。close：结束的 SQL 语句。item：参数变量名。separator：分隔符。\n2.4  SQL片段抽取Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的\n&lt;!--抽取sql片段简化编写--&gt;&lt;sql id=&quot;selectStudent&quot; select * from student&lt;/sql&gt;&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;student&quot;&gt;    &lt;include refid=&quot;selectStudent&quot;&gt;&lt;/include&gt; where id=#&#123;id&#125;&lt;/select&gt;&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;student&quot;&gt;    &lt;include refid=&quot;selectStudent&quot;&gt;&lt;/include&gt;    &lt;where&gt;        &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt;            #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n总结语法:\n我们可以将一些重复性的 SQL 语句进行抽取，以达到复用的效果。 \n-  &lt;sql&gt;：抽取 SQL 语句标签。 -  &lt;include&gt;：引入 SQL 片段标签。    &lt;sql id=“片段唯一标识”&gt;抽取的 SQL 语句&lt;/sql&gt; &lt;include refid=“片段唯一标识”/&gt; \n\n2.5 知识小结MyBatis映射文件配置：\n&lt;select&gt;：查询&lt;insert&gt;：插入&lt;update&gt;：修改&lt;delete&gt;：删除&lt;where&gt;：where条件&lt;if&gt;：if判断&lt;foreach&gt;：循环&lt;sql&gt;：sql片段抽取\n\n\n\n三. 分页插件3.1 分页插件介绍\n\n分页可以将很多条结果进行分页显示。 \n 如果当前在第一页，则没有上一页。如果当前在最后一页，则没有下一页。 \n 需要明确当前是第几页，这一页中显示多少条结果。    \nMyBatis分页插件总结\n在企业级开发中，分页也是一种常见的技术。而目前使用的 MyBatis 是不带分页功能的，如果想实现分页的 功能，需要我们手动编写 LIMIT 语句。但是不同的数据库实现分页的 SQL 语句也是不同的，所以手写分页 成本较高。这个时候就可以借助分页插件来帮助我们实现分页功能。 \nPageHelper：第三方分页助手。将复杂的分页操作进行封装，从而让分页功能变得非常简单。    \n\n\n\n3.2 分页插件的使用MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据\n开发步骤：\n①导入与PageHelper的jar包\n②在mybatis核心配置文件中配置PageHelper插件\n&lt;!-- 注意：分页助手的插件  配置在通用mapper之前 --&gt;&lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;    &lt;!-- 指定方言 --&gt;    &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;&lt;/plugin&gt;\n\n③测试分页数据获取\n@Testpublic void testPageHelper()&#123;    //设置分页参数    PageHelper.startPage(1,2);    List&lt;User&gt; select = userMapper2.select(null);    for(User user : select)&#123;        System.out.println(user);    &#125;&#125;\n\n3.3 分页插件的参数获取获得分页相关的其他参数：\n//其他分页的数据PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(select);System.out.println(&quot;总条数：&quot;+pageInfo.getTotal());System.out.println(&quot;总页数：&quot;+pageInfo.getPages());System.out.println(&quot;当前页：&quot;+pageInfo.getPageNum());System.out.println(&quot;每页显示长度：&quot;+pageInfo.getPageSize());System.out.println(&quot;是否第一页：&quot;+pageInfo.isIsFirstPage());System.out.println(&quot;是否最后一页：&quot;+pageInfo.isIsLastPage());\n\n3.4  分页插件知识小结​    分页：可以将很多条结果进行分页显示。 \n\n分页插件 jar 包： pagehelper-5.1.10.jar jsqlparser-3.1.jar \n\n ：集成插件标签。 \n\n分页助手相关 API \n​    1.PageHelper：分页助手功能类。\n\nstartPage()：设置分页参数 \nPageInfo：分页相关参数功能类。 \ngetTotal()：获取总条数 \ngetPages()：获取总页数\n getPageNum()：获取当前页\n getPageSize()：获取每页显示条数\n getPrePage()：获取上一页 \ngetNextPage()：获取下一页 \nisIsFirstPage()：获取是否是第一页 \nisIsLastPage()：获取是否是最后一页    \n\n\n\n四.MyBatis的多表操作4.1 多表模型介绍我们之前学习的都是基于单表操作的，而实际开发中，随着业务难度的加深，肯定需要多表操作的。 \n\n 多表模型分类 一对一：在任意一方建立外键，关联对方的主键。\n 一对多：在多的一方建立外键，关联一的一方的主键。\n 多对多：借助中间表，中间表至少两个字段，分别关联两张表的主键。    \n\n4.2 多表模型一对一操作\n一对一模型： 人和身份证，一个人只有一个身份证\n\n代码实现\n\n步骤一: sql语句准备\nCREATE TABLE person(\tid INT PRIMARY KEY AUTO_INCREMENT,\tNAME VARCHAR(20),\tage INT);INSERT INTO person VALUES (NULL,&#x27;张三&#x27;,23);INSERT INTO person VALUES (NULL,&#x27;李四&#x27;,24);INSERT INTO person VALUES (NULL,&#x27;王五&#x27;,25);CREATE TABLE card(\tid INT PRIMARY KEY AUTO_INCREMENT,\tnumber VARCHAR(30),\tpid INT,\tCONSTRAINT cp_fk FOREIGN KEY (pid) REFERENCES person(id));INSERT INTO card VALUES (NULL,&#x27;12345&#x27;,1);INSERT INTO card VALUES (NULL,&#x27;23456&#x27;,2);INSERT INTO card VALUES (NULL,&#x27;34567&#x27;,3);\n步骤二:配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.table01.OneToOneMapper&quot;&gt;    &lt;!--配置字段和实体对象属性的映射关系--&gt;    &lt;resultMap id=&quot;oneToOne&quot; type=&quot;card&quot;&gt;        &lt;id column=&quot;cid&quot; property=&quot;id&quot; /&gt;        &lt;result column=&quot;number&quot; property=&quot;number&quot; /&gt;        &lt;!--            association：配置被包含对象的映射关系            property：被包含对象的变量名            javaType：被包含对象的数据类型        --&gt;        &lt;association property=&quot;p&quot; javaType=&quot;person&quot;&gt;            &lt;id column=&quot;pid&quot; property=&quot;id&quot; /&gt;            &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;            &lt;result column=&quot;age&quot; property=&quot;age&quot; /&gt;        &lt;/association&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectAll&quot; resultMap=&quot;oneToOne&quot;&gt;        SELECT c.id cid,number,pid,NAME,age FROM card c,person p WHERE c.pid=p.id    &lt;/select&gt;&lt;/mapper&gt;\n步骤三：测试类\n@Test   public void selectAll() throws Exception&#123;       //1.加载核心配置文件       InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);            //2.获取SqlSession工厂对象       SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);            //3.通过工厂对象获取SqlSession对象       SqlSession sqlSession = sqlSessionFactory.openSession(true);            //4.获取OneToOneMapper接口的实现类对象       OneToOneMapper mapper = sqlSession.getMapper(OneToOneMapper.class);            //5.调用实现类的方法，接收结果       List&lt;Card&gt; list = mapper.selectAll();            //6.处理结果       for (Card c : list) &#123;           System.out.println(c);       &#125;            //7.释放资源       sqlSession.close();       is.close();   &#125;\n\n3.一对一配置总结:\n&lt;resultMap&gt;：配置字段和对象属性的映射关系标签。    id 属性：唯一标识    type 属性：实体对象类型&lt;id&gt;：配置主键映射关系标签。&lt;result&gt;：配置非主键映射关系标签。    column 属性：表中字段名称    property 属性： 实体对象变量名称&lt;association&gt;：配置被包含对象的映射关系标签。    property 属性：被包含对象的变量名    javaType 属性：被包含对象的数据类型\n\n4.3 多表模型一对多操作\n一对多模型： 一对多模型：班级和学生，一个班级可以有多个学生。    \n\n代码实现\n\n步骤一: sql语句准备\nCREATE TABLE classes(\tid INT PRIMARY KEY AUTO_INCREMENT,\tNAME VARCHAR(20));INSERT INTO classes VALUES (NULL,&#x27;黑马一班&#x27;);INSERT INTO classes VALUES (NULL,&#x27;黑马二班&#x27;);CREATE TABLE student(\tid INT PRIMARY KEY AUTO_INCREMENT,\tNAME VARCHAR(30),\tage INT,\tcid INT,\tCONSTRAINT cs_fk FOREIGN KEY (cid) REFERENCES classes(id));INSERT INTO student VALUES (NULL,&#x27;张三&#x27;,23,1);INSERT INTO student VALUES (NULL,&#x27;李四&#x27;,24,1);INSERT INTO student VALUES (NULL,&#x27;王五&#x27;,25,2);INSERT INTO student VALUES (NULL,&#x27;赵六&#x27;,26,2);\n步骤二:配置文件\n&lt;mapper namespace=&quot;com.itheima.table02.OneToManyMapper&quot;&gt;    &lt;resultMap id=&quot;oneToMany&quot; type=&quot;classes&quot;&gt;        &lt;id column=&quot;cid&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;cname&quot; property=&quot;name&quot;/&gt;        &lt;!--            collection：配置被包含的集合对象映射关系            property：被包含对象的变量名            ofType：被包含对象的实际数据类型        --&gt;        &lt;collection property=&quot;students&quot; ofType=&quot;student&quot;&gt;            &lt;id column=&quot;sid&quot; property=&quot;id&quot;/&gt;            &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt;            &lt;result column=&quot;sage&quot; property=&quot;age&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectAll&quot; resultMap=&quot;oneToMany&quot;&gt;        SELECT c.id cid,c.name cname,s.id sid,s.name sname,s.age sage FROM classes c,student s WHERE c.id=s.cid    &lt;/select&gt;&lt;/mapper&gt;\n步骤三：测试类\n@Testpublic void selectAll() throws Exception&#123;    //1.加载核心配置文件    InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);         //2.获取SqlSession工厂对象    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);         //3.通过工厂对象获取SqlSession对象    SqlSession sqlSession = sqlSessionFactory.openSession(true);         //4.获取OneToManyMapper接口的实现类对象    OneToManyMapper mapper = sqlSession.getMapper(OneToManyMapper.class);         //5.调用实现类的方法，接收结果    List&lt;Classes&gt; classes = mapper.selectAll();         //6.处理结果    for (Classes cls : classes) &#123;        System.out.println(cls.getId() + &quot;,&quot; + cls.getName());        List&lt;Student&gt; students = cls.getStudents();        for (Student student : students) &#123;            System.out.println(&quot;\\t&quot; + student);        &#125;    &#125;         //7.释放资源    sqlSession.close();    is.close();&#125;\n\n3.一对多配置文件总结：\n&lt;resultMap&gt;：配置字段和对象属性的映射关系标签。    id 属性：唯一标识    type 属性：实体对象类型&lt;id&gt;：配置主键映射关系标签。&lt;result&gt;：配置非主键映射关系标签。    column 属性：表中字段名称    property 属性： 实体对象变量名称&lt;collection&gt;：配置被包含集合对象的映射关系标签。    property 属性：被包含集合对象的变量名    ofType 属性：集合中保存的对象数据类型\n\n\n\n4.4 多表模型多对多操作\n多对多模型：学生和课程，一个学生可以选择多门课程、一个课程也可以被多个学生所选择。       \n\n代码实现\n\n步骤一: sql语句准备\nCREATE TABLE course(\tid INT PRIMARY KEY AUTO_INCREMENT,\tNAME VARCHAR(20));INSERT INTO course VALUES (NULL,&#x27;语文&#x27;);INSERT INTO course VALUES (NULL,&#x27;数学&#x27;);CREATE TABLE stu_cr(\tid INT PRIMARY KEY AUTO_INCREMENT,\tsid INT,\tcid INT,\tCONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id),\tCONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id));INSERT INTO stu_cr VALUES (NULL,1,1);INSERT INTO stu_cr VALUES (NULL,1,2);INSERT INTO stu_cr VALUES (NULL,2,1);INSERT INTO stu_cr VALUES (NULL,2,2);\n步骤二:配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.table03.ManyToManyMapper&quot;&gt;    &lt;resultMap id=&quot;manyToMany&quot; type=&quot;student&quot;&gt;        &lt;id column=&quot;sid&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt;        &lt;result column=&quot;sage&quot; property=&quot;age&quot;/&gt;        &lt;collection property=&quot;courses&quot; ofType=&quot;course&quot;&gt;            &lt;id column=&quot;cid&quot; property=&quot;id&quot;/&gt;            &lt;result column=&quot;cname&quot; property=&quot;name&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectAll&quot; resultMap=&quot;manyToMany&quot;&gt;        SELECT sc.sid,s.name sname,s.age sage,sc.cid,c.name cname FROM student s,course c,stu_cr sc WHERE sc.sid=s.id AND sc.cid=c.id    &lt;/select&gt;&lt;/mapper&gt;\n步骤三：测试类\n@Test   public void selectAll() throws Exception&#123;       //1.加载核心配置文件       InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);            //2.获取SqlSession工厂对象       SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);            //3.通过工厂对象获取SqlSession对象       SqlSession sqlSession = sqlSessionFactory.openSession(true);            //4.获取ManyToManyMapper接口的实现类对象       ManyToManyMapper mapper = sqlSession.getMapper(ManyToManyMapper.class);            //5.调用实现类的方法，接收结果       List&lt;Student&gt; students = mapper.selectAll();            //6.处理结果       for (Student student : students) &#123;           System.out.println(student.getId() + &quot;,&quot; + student.getName() + &quot;,&quot; + student.getAge());           List&lt;Course&gt; courses = student.getCourses();           for (Course cours : courses) &#123;               System.out.println(&quot;\\t&quot; + cours);           &#125;       &#125;            //7.释放资源       sqlSession.close();       is.close();   &#125;   \n\n3.多对多配置文件总结：\n&lt;resultMap&gt;：配置字段和对象属性的映射关系标签。\tid 属性：唯一标识\ttype 属性：实体对象类型 &lt;id&gt;：配置主键映射关系标签。 &lt;result&gt;：配置非主键映射关系标签。\tcolumn 属性：表中字段名称\tproperty 属性： 实体对象变量名称&lt;collection&gt;：配置被包含集合对象的映射关系标签。\tproperty 属性：被包含集合对象的变量名\tofType 属性：集合中保存的对象数据类型\n\n\n\n4.5 多表模型操作总结 &lt;resultMap&gt;：配置字段和对象属性的映射关系标签。    id 属性：唯一标识    type 属性：实体对象类型&lt;id&gt;：配置主键映射关系标签。&lt;result&gt;：配置非主键映射关系标签。\tcolumn 属性：表中字段名称\tproperty 属性： 实体对象变量名称&lt;association&gt;：配置被包含对象的映射关系标签。\tproperty 属性：被包含对象的变量名\tjavaType 属性：被包含对象的数据类型&lt;collection&gt;：配置被包含集合对象的映射关系标签。\tproperty 属性：被包含集合对象的变量名\tofType 属性：集合中保存的对象数据类型\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["Java基础"],"tags":["Mybaties","Java"]},{"title":"Mybaties-3","url":"/2021/09/30/mybatis-3/","content":"一.Mybatis注解开发单表操作1.1 MyBatis的常用注解这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper\n映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。\n@Insert：实现新增\n@Update：实现更新\n@Delete：实现删除\n@Select：实现查询\n@Result：实现结果集封装\n@Results：可以与@Result 一起使用，封装多个结果集\n@One：实现一对一结果集封装\n@Many：实现一对多结果集封装\n1.2 MyBatis的增删改查我们完成简单的student表的增删改查的操作\n\n步骤一:创建mapper接口\npublic interface StudentMapper &#123;    //查询全部    @Select(&quot;SELECT * FROM student&quot;)    public abstract List&lt;Student&gt; selectAll();    //新增操作    @Insert(&quot;INSERT INTO student VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)&quot;)    public abstract Integer insert(Student stu);    //修改操作    @Update(&quot;UPDATE student SET name=#&#123;name&#125;,age=#&#123;age&#125; WHERE id=#&#123;id&#125;&quot;)    public abstract Integer update(Student stu);    //删除操作    @Delete(&quot;DELETE FROM student WHERE id=#&#123;id&#125;&quot;)    public abstract Integer delete(Integer id);&#125;\n步骤二：测试类\npublic class Test01 &#123;    @Test    public void selectAll() throws Exception&#123;        //1.加载核心配置文件        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);        //2.获取SqlSession工厂对象        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);        //3.通过工厂对象获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession(true);        //4.获取StudentMapper接口的实现类对象        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);        //5.调用实现类对象中的方法，接收结果        List&lt;Student&gt; list = mapper.selectAll();        //6.处理结果        for (Student student : list) &#123;            System.out.println(student);        &#125;        //7.释放资源        sqlSession.close();        is.close();    &#125;    @Test    public void insert() throws Exception&#123;        //1.加载核心配置文件        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);        //2.获取SqlSession工厂对象        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);        //3.通过工厂对象获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession(true);        //4.获取StudentMapper接口的实现类对象        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);        //5.调用实现类对象中的方法，接收结果        Student stu = new Student(4,&quot;赵六&quot;,26);        Integer result = mapper.insert(stu);        //6.处理结果        System.out.println(result);        //7.释放资源        sqlSession.close();        is.close();    &#125;    @Test    public void update() throws Exception&#123;        //1.加载核心配置文件        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);        //2.获取SqlSession工厂对象        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);        //3.通过工厂对象获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession(true);        //4.获取StudentMapper接口的实现类对象        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);        //5.调用实现类对象中的方法，接收结果        Student stu = new Student(4,&quot;赵六&quot;,36);        Integer result = mapper.update(stu);        //6.处理结果        System.out.println(result);        //7.释放资源        sqlSession.close();        is.close();    &#125;    @Test    public void delete() throws Exception&#123;        //1.加载核心配置文件        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);        //2.获取SqlSession工厂对象        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);        //3.通过工厂对象获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession(true);        //4.获取StudentMapper接口的实现类对象        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);        //5.调用实现类对象中的方法，接收结果        Integer result = mapper.delete(4);        //6.处理结果        System.out.println(result);        //7.释放资源        sqlSession.close();        is.close();    &#125;&#125;\n注意：\n修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可\n\n\n&lt;mappers&gt;    &lt;!--扫描使用注解的类--&gt;    &lt;mapper class=&quot;com.itheima.mapper.UserMapper&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt;\n\n​    或者指定扫描包含映射关系的接口所在的包也可以\n&lt;mappers&gt;    &lt;!--扫描使用注解的类所在的包--&gt;    &lt;package name=&quot;com.itheima.mapper&quot;&gt;&lt;/package&gt;&lt;/mappers&gt;\n\n1.3 注解开发总结注解可以简化开发操作，省略映射配置文件的编写。 \n\n常用注解 \n@Select(“查询的 SQL 语句”)：执行查询操作注解\n @Insert(“查询的 SQL 语句”)：执行新增操作注解\n @Update(“查询的 SQL 语句”)：执行修改操作注解\n @Delete(“查询的 SQL 语句”)：执行删除操作注解 \n\n配置映射关系 \n&lt;mappers&gt; &lt;package name=&quot;接口所在包&quot;/&gt; &lt;/mappers&gt;    \n\n二.MyBatis注解开发的多表操作2.1  MyBatis的注解实现复杂映射开发实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置\n\n\n2.2  一对一查询2.2.1 一对一查询的模型一对一查询的需求：查询一个用户信息，与此同时查询出该用户对应的身份证信息\n\n2.2.2 一对一查询的语句对应的sql语句：\nSELECT * FROM card；SELECT * FROM person WHERE id=#&#123;id&#125;;\n\n2.2.3 创建PersonMapper接口public interface PersonMapper &#123;    //根据id查询    @Select(&quot;SELECT * FROM person WHERE id=#&#123;id&#125;&quot;)    public abstract Person selectById(Integer id);&#125;\n\n2.2.4 使用注解配置Mapperpublic interface CardMapper &#123;    //查询全部    @Select(&quot;SELECT * FROM card&quot;)    @Results(&#123;            @Result(column = &quot;id&quot;,property = &quot;id&quot;),            @Result(column = &quot;number&quot;,property = &quot;number&quot;),            @Result(                    property = &quot;p&quot;,             // 被包含对象的变量名                    javaType = Person.class,    // 被包含对象的实际数据类型                    column = &quot;pid&quot;,             // 根据查询出的card表中的pid字段来查询person表                    /*                        one、@One 一对一固定写法                        select属性：指定调用哪个接口中的哪个方法                     */                    one = @One(select = &quot;com.itheima.one_to_one.PersonMapper.selectById&quot;)            )    &#125;)    public abstract List&lt;Card&gt; selectAll();&#125;\n\n2.2.5 测试类public class Test01 &#123;    @Test    public void selectAll() throws Exception&#123;        //1.加载核心配置文件        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);        //2.获取SqlSession工厂对象        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);        //3.通过工厂对象获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession(true);        //4.获取CardMapper接口的实现类对象        CardMapper mapper = sqlSession.getMapper(CardMapper.class);        //5.调用实现类对象中的方法，接收结果        List&lt;Card&gt; list = mapper.selectAll();        //6.处理结果        for (Card card : list) &#123;            System.out.println(card);        &#125;        //7.释放资源        sqlSession.close();        is.close();    &#125;&#125;\n\n2.2.6  一对一配置总结@Results：封装映射关系的父注解。\tResult[] value()：定义了 Result 数组@Result：封装映射关系的子注解。\tcolumn 属性：查询出的表中字段名称\tproperty 属性：实体对象中的属性名称\tjavaType 属性：被包含对象的数据类型\tone 属性：一对一查询固定属性 @One：一对一查询的注解。\tselect 属性：指定调用某个接口中的方法\n\n\n\n2.3 一对多查询2.3.1 一对多查询的模型一对多查询的需求：查询一个课程，与此同时查询出该该课程对应的学生信息\n\n2.3.2 一对多查询的语句对应的sql语句：\nSELECT * FROM classesSELECT * FROM student WHERE cid=#&#123;cid&#125;\n\n2.3.3 创建StudentMapper接口public interface StudentMapper &#123;    //根据cid查询student表    @Select(&quot;SELECT * FROM student WHERE cid=#&#123;cid&#125;&quot;)    public abstract List&lt;Student&gt; selectByCid(Integer cid);&#125;\n\n2.3.4 使用注解配置Mapperpublic interface ClassesMapper &#123;    //查询全部    @Select(&quot;SELECT * FROM classes&quot;)    @Results(&#123;            @Result(column = &quot;id&quot;,property = &quot;id&quot;),            @Result(column = &quot;name&quot;,property = &quot;name&quot;),            @Result(                    property = &quot;students&quot;,  // 被包含对象的变量名                    javaType = List.class,  // 被包含对象的实际数据类型                    column = &quot;id&quot;,          // 根据查询出的classes表的id字段来查询student表                    /*                        many、@Many 一对多查询的固定写法                        select属性：指定调用哪个接口中的哪个查询方法                     */                    many = @Many(select = &quot;com.itheima.one_to_many.StudentMapper.selectByCid&quot;)            )    &#125;)    public abstract List&lt;Classes&gt; selectAll();&#125;\n\n2.3.5 测试类public class Test01 &#123;    @Test    public void selectAll() throws Exception&#123;        //1.加载核心配置文件        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);        //2.获取SqlSession工厂对象        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);        //3.通过工厂对象获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession(true);        //4.获取ClassesMapper接口的实现类对象        ClassesMapper mapper = sqlSession.getMapper(ClassesMapper.class);        //5.调用实现类对象中的方法，接收结果        List&lt;Classes&gt; list = mapper.selectAll();        //6.处理结果        for (Classes cls : list) &#123;            System.out.println(cls.getId() + &quot;,&quot; + cls.getName());            List&lt;Student&gt; students = cls.getStudents();            for (Student student : students) &#123;                System.out.println(&quot;\\t&quot; + student);            &#125;        &#125;        //7.释放资源        sqlSession.close();        is.close();    &#125;&#125;\n\n2.3.6 一对多配置总结@Results：封装映射关系的父注解。\tResult[] value()：定义了 Result 数组@Result：封装映射关系的子注解。\tcolumn 属性：查询出的表中字段名称\tproperty 属性：实体对象中的属性名称\tjavaType 属性：被包含对象的数据类型\tmany 属性：一对多查询固定属性@Many：一对多查询的注解。\tselect 属性：指定调用某个接口中的方法\n\n\n\n2.4  多对多查询2.4.1 多对多查询的模型多对多查询的需求：查询学生以及所对应的课程信息\n\n2.4.2 多对多查询的语句对应的sql语句：\nSELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.idSELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#&#123;id&#125;\n\n\n\n2.4.3  添加CourseMapper 接口方法public interface CourseMapper &#123;    //根据学生id查询所选课程    @Select(&quot;SELECT c.id,c.name FROM stu_cr sc,course c WHERE sc.cid=c.id AND sc.sid=#&#123;id&#125;&quot;)    public abstract List&lt;Course&gt; selectBySid(Integer id);&#125;\n\n2.4.4 使用注解配置Mapperpublic interface StudentMapper &#123;    //查询全部    @Select(&quot;SELECT DISTINCT s.id,s.name,s.age FROM student s,stu_cr sc WHERE sc.sid=s.id&quot;)    @Results(&#123;            @Result(column = &quot;id&quot;,property = &quot;id&quot;),            @Result(column = &quot;name&quot;,property = &quot;name&quot;),            @Result(column = &quot;age&quot;,property = &quot;age&quot;),            @Result(                    property = &quot;courses&quot;,   // 被包含对象的变量名                    javaType = List.class,  // 被包含对象的实际数据类型                    column = &quot;id&quot;,          // 根据查询出student表的id来作为关联条件，去查询中间表和课程表                    /*                        many、@Many 一对多查询的固定写法                        select属性：指定调用哪个接口中的哪个查询方法                     */                    many = @Many(select = &quot;com.itheima.many_to_many.CourseMapper.selectBySid&quot;)            )    &#125;)    public abstract List&lt;Student&gt; selectAll();&#125;\n\n2.4.5 测试类public class Test01 &#123;    @Test    public void selectAll() throws Exception&#123;        //1.加载核心配置文件        InputStream is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);        //2.获取SqlSession工厂对象        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);        //3.通过工厂对象获取SqlSession对象        SqlSession sqlSession = sqlSessionFactory.openSession(true);        //4.获取StudentMapper接口的实现类对象        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);        //5.调用实现类对象中的方法，接收结果        List&lt;Student&gt; list = mapper.selectAll();        //6.处理结果        for (Student student : list) &#123;            System.out.println(student.getId() + &quot;,&quot; + student.getName() + &quot;,&quot; + student.getAge());            List&lt;Course&gt; courses = student.getCourses();            for (Course cours : courses) &#123;                System.out.println(&quot;\\t&quot; + cours);            &#125;        &#125;        //7.释放资源        sqlSession.close();        is.close();    &#125;&#125;\n\n2.4.6 多对多配置总结@Results：封装映射关系的父注解。\tResult[] value()：定义了 Result 数组@Result：封装映射关系的子注解。\tcolumn 属性：查询出的表中字段名称\tproperty 属性：实体对象中的属性名称\tjavaType 属性：被包含对象的数据类型\tmany 属性：一对多查询固定属性@Many：一对多查询的注解。\tselect 属性：指定调用某个接口中的方法\n\n\n\n三.构建sql3.1 SQL 构建对象介绍\n我们之前通过注解开发时，相关 SQL 语句都是自己直接拼写的。一些关键字写起来比较麻烦、而且容易出错。 \n MyBatis 给我们提供了 org.apache.ibatis.jdbc.SQL 功能类，专门用于构建 SQL 语句    \n\n\n3.2  查询功能的实现\n定义功能类并提供获取查询的 SQL 语句的方法。 \n\n@SelectProvider：生成查询用的 SQL 语句注解。\n type 属性：生成 SQL 语句功能类对象 \n method 属性：指定调用方法    \n\n\n3.3  新增功能的实现\n定义功能类并提供获取新增的 SQL 语句的方法。 \n\n@InsertProvider：生成新增用的 SQL 语句注解。 \ntype 属性：生成 SQL 语句功能类对象 \nmethod 属性：指定调用方法    \n\n\n3.4  修改功能的实现\n定义功能类并提供获取修改的 SQL 语句的方法。 \n\n @UpdateProvider：生成修改用的 SQL 语句注解。 \n\n\n  type 属性：生成 SQL 语句功能类对象\n   method 属性：指定调用方法    \n3.5  删除功能的实现\n定义功能类并提供获取删除的 SQL 语句的方法。 \n\n@DeleteProvider：生成删除用的 SQL 语句注解。\n type 属性：生成 SQL 语句功能类对象 \n method 属性：指定调用方法    \n\n\n四.综合案例4.1  系统介绍​         我们之前在做学生管理系统时，使用的是原始JDBC操作数据库的，操作非常麻烦，现在我们使用MyBatis操作数据库，简化Dao的开发。\n4.2  环境搭建（略）4.3  代码改造\n步骤一：新增MyBatis配置文件 MyBatisConfig.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!--MyBatis的DTD约束--&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration 核心根标签--&gt;&lt;configuration&gt;    &lt;!--引入数据库连接的配置文件--&gt;    &lt;properties resource=&quot;config.properties&quot;/&gt;    &lt;!--配置LOG4J--&gt;    &lt;settings&gt;        &lt;setting name=&quot;logImpl&quot; value=&quot;log4j&quot;/&gt;    &lt;/settings&gt;    &lt;!--environments配置数据库环境，环境可以有多个。default属性指定使用的是哪个--&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;!--environment配置数据库环境  id属性唯一标识--&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;!-- transactionManager事务管理。  type属性，采用JDBC默认的事务--&gt;            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;            &lt;!-- dataSource数据源信息   type属性 连接池--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;!-- property获取数据库连接的配置信息 --&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot; /&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot; /&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot; /&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot; /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!--配置映射关系--&gt;    &lt;mappers&gt;        &lt;package name=&quot;com.itheima&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n步骤二: 删除StudentDaoImpl，修改StudentDao\n  package com.itheima.dao;  import com.itheima.domain.Student;  import org.apache.ibatis.annotations.Delete;  import org.apache.ibatis.annotations.Insert;  import org.apache.ibatis.annotations.Select;  import org.apache.ibatis.annotations.Update;  import java.util.ArrayList;  /*      Dao层接口   */  public interface StudentDao &#123;      //查询所有学生信息      @Select(&quot;SELECT * FROM student&quot;)      public abstract ArrayList&lt;Student&gt; findAll();      //条件查询，根据id获取学生信息      @Select(&quot;SELECT * FROM student WHERE sid=#&#123;sid&#125;&quot;)      public abstract Student findById(Integer sid);            //新增学生信息      @Insert(&quot;INSERT INTO student VALUES (#&#123;sid&#125;,#&#123;name&#125;,#&#123;age&#125;,#&#123;birthday&#125;)&quot;)      public abstract int insert(Student stu);            //修改学生信息      @Update(&quot;UPDATE student SET name=#&#123;name&#125;,age=#&#123;age&#125;,birthday=#&#123;birthday&#125; WHERE sid=#&#123;sid&#125;&quot;)      public abstract int update(Student stu);            //删除学生信息      @Delete(&quot;DELETE FROM student WHERE sid=#&#123;sid&#125;&quot;)      public abstract int delete(Integer sid);  &#125;\n步骤三：修改StudentServiceImpl\npackage com.itheima.service.impl;import com.itheima.dao.StudentDao;import com.itheima.domain.Student;import com.itheima.service.StudentService;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.List;/** * 学生的业务层实现类 * @author 黑马程序员 * @Company http://www.itheima.com */public class StudentServiceImpl implements StudentService &#123;    @Override    public List&lt;Student&gt; findAll() &#123;        ArrayList&lt;Student&gt; list = null;        SqlSession sqlSession = null;        InputStream is = null;        try&#123;            //1.加载核心配置文件            is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);            //2.获取SqlSession工厂对象            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);            //3.通过工厂对象获取SqlSession对象            sqlSession = sqlSessionFactory.openSession(true);            //4.获取StudentDao接口的实现类对象            StudentDao mapper = sqlSession.getMapper(StudentDao.class);            //5.调用实现类对象的方法，接收结果            list = mapper.findAll();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //6.释放资源            if(sqlSession != null) &#123;                sqlSession.close();            &#125;            if(is != null) &#123;                try &#123;                    is.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        //7.返回结果        return list;    &#125;    @Override    public Student findById(Integer sid) &#123;        Student stu = null;        SqlSession sqlSession = null;        InputStream is = null;        try&#123;            //1.加载核心配置文件            is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);            //2.获取SqlSession工厂对象            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);            //3.通过工厂对象获取SqlSession对象            sqlSession = sqlSessionFactory.openSession(true);            //4.获取StudentDao接口的实现类对象            StudentDao mapper = sqlSession.getMapper(StudentDao.class);            //5.调用实现类对象的方法，接收结果            stu = mapper.findById(sid);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //6.释放资源            if(sqlSession != null) &#123;                sqlSession.close();            &#125;            if(is != null) &#123;                try &#123;                    is.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        //7.返回结果        return stu;    &#125;    @Override    public void save(Student student) &#123;        SqlSession sqlSession = null;        InputStream is = null;        try&#123;            //1.加载核心配置文件            is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);            //2.获取SqlSession工厂对象            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);            //3.通过工厂对象获取SqlSession对象            sqlSession = sqlSessionFactory.openSession(true);            //4.获取StudentDao接口的实现类对象            StudentDao mapper = sqlSession.getMapper(StudentDao.class);            //5.调用实现类对象的方法，接收结果            mapper.insert(student);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //6.释放资源            if(sqlSession != null) &#123;                sqlSession.close();            &#125;            if(is != null) &#123;                try &#123;                    is.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    @Override    public void update(Student student) &#123;        SqlSession sqlSession = null;        InputStream is = null;        try&#123;            //1.加载核心配置文件            is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);            //2.获取SqlSession工厂对象            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);            //3.通过工厂对象获取SqlSession对象            sqlSession = sqlSessionFactory.openSession(true);            //4.获取StudentDao接口的实现类对象            StudentDao mapper = sqlSession.getMapper(StudentDao.class);            //5.调用实现类对象的方法，接收结果            mapper.update(student);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //6.释放资源            if(sqlSession != null) &#123;                sqlSession.close();            &#125;            if(is != null) &#123;                try &#123;                    is.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    @Override    public void delete(Integer sid) &#123;        SqlSession sqlSession = null;        InputStream is = null;        try&#123;            //1.加载核心配置文件            is = Resources.getResourceAsStream(&quot;MyBatisConfig.xml&quot;);            //2.获取SqlSession工厂对象            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);            //3.通过工厂对象获取SqlSession对象            sqlSession = sqlSessionFactory.openSession(true);            //4.获取StudentDao接口的实现类对象            StudentDao mapper = sqlSession.getMapper(StudentDao.class);            //5.调用实现类对象的方法，接收结果            mapper.delete(sid);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //6.释放资源            if(sqlSession != null) &#123;                sqlSession.close();            &#125;            if(is != null) &#123;                try &#123;                    is.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;\n\n","categories":["Java基础"],"tags":["Mybaties","Java"]}]